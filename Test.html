p<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<ㅔ>
    
    
        <h2>구조체</h2><br>
        <h3>구조체 이해</h3><br>
        <p data-ke-size="size18">
        사용자 정의데이터 타입<br>       
        관련 있는 데이터를 묶어서 처리할 수 있는 자료 구조<br>
        서로 다은 데이터 타입의 묶음<br>
        서로 다은 데이터 타입을 묶어서 처리할 수있도록 사용자가 정의하는 데이터 타입<br><br>
 
        구조체 정의방법</p>
        <div class="well">
            * 구조체의 멤버로 일반 변수뿐만 아니라 배열이나 포인터 선언 가능<br>
            * 구조체를 정의하면 새로운 데이터형이 만들어짐<br>
            * 구조체 정의 -> 메모리 할당의 의미는 아님<br>
            * 구조체형 변수 선언 -> 메모리에 할당<br>
            * struct 구조체명 { <br>
              데이터형 멤버명; <br>
              데이터형 멤버명; <br>
              ...... <br>
              };<br>
        </div><br>
        <p data-ke-size="size18"></p>
        구조체의 크기는 모든 멤버들의 크기의 합보다 크거나 같음<br>
        구조체 멤버 중 가장 큰 멤버의 크기를 기준으로 멤버 할당(Padding)<br>
        구조체의 크기를 구하려면 sizeof 연산자를 이용함<br></p>
        
        
        
        <h3>구조체 처리</h3><br>
        <p><h4>1.초기화</h4>
            <ul>
                <li>선언 시 초기화는 배열 초기화 동일</li>
                <li>{} 안에 멤버들의 초기값을 순서대로 나열</li>
                <li>{} 안에 지정한 초기값이 멤버의 개수보다 부족하면 나머지 멤버들은 0으로 초기화</li>
                <li>멤버 접근 연산자 "."을 이용한 초기화 가능</li>
                <li>같은 구조체형의 변수들끼리는 서로 초기화나 대입이 가능함</li>
                <li>구조체 간의 초기화 : 멤버 대 멤버 초기화</li>
                <li>구조체 간의 대입 : 멤버 대 멤버 대입</li>
            </ul><br>
            <h4>2. 구조체 포인터</h4><br><br>
            <p data-ke-size="size18">
            구조체 포인터를 선언하는 것이 가능<br>
            구조체 포인터로 구조체의 멤버에게 접글할 때는 "->" 간접 접근 연산자를 사용<br></p>
           

        </p>
        <p data-ke-size="size16">포인터 오류</p>
        <ul>
            <li> 포인터도 변수이므로 반드시 초기화 해야 함</li>
            <li> 포인터 변수를 초기화하지 않고 사용하면 실행 에러가 발생함</li>
            <li> 널포인터: 포인터가 다른 변수를 가리키지 않을 때는 NULL(0)로 초기화함</li>
            <li> 포인터를 안전하게 사용하려면 우선 포인터가 널 포인터인지를 검사</li>
            <li> 포인터 변수의 데이터형이 반드시 포인터 변수가 가리키는 변수의 데이터형과 일치해야함</li>
        </ul><br>
        
        
    </ul>
    <p data-ke-size="size16">배열의 시작 주소로 초기화된 포인터를 이용해서 배열의 모든 원소에 접근 가능 <br>
        포인터 변수를 배열 이름인 것처럼 사용 가능<br>
        포인터와 +,- 연산<br></p>
        <div class="well">
            * p + N : p가 가리키는 데이터형 N개 크기만큼 증가된 주소가 연산의 결과<br>
            * p - N : p가 가리키는 데이터형 N개 크기만큼 감소된 주소가 연산의 결과<br>
        </div></p>
        
        
        <h4>[2]포인터와 배열 원소</h4>
        <p>
            배열의 원소를 가리키는 포인터는 배열의 어떤 원소든지 가리킬 수 있음
            포인터가 배열의 원소가 아닌 일반 변수를 가리킬 때도 *(p+i) == p[1]는 항상 성립함 
            <div class="well">
                * 배열과 포인터의 차이점 *<br>
                * 배열이 메모리에 할당되고 나면 , 배열의 시작 주소 변경 불가<br>
                * 포인터 변수는 값을 변경할 수 있으므로 , 포인터 변수에 보관된
                주소는 변경 가능<br>
            </div>
        </p>
        
        
                <ul>
                <li>포인터 배열은 주소를 보관하는 배열임</li>
                <li>포인터 배열을 이용하여 각 변수를 참조하는 것이 가능함</li>
                <li>여러 개의 문자열을 하나로 묶어 처리하는 방법으로 문자 포인터 배열을 이용할 수 있음</li>
                </ul>
        
        
        
        
        <p><h3>포인터 이용</h3>
            <h4>[1]포인터 증감 연산</h4>
            
            포인터와++, 연산 : 포인터에대한 증감 연산 (++,--) 도 포인터형에 의해 연산의 결과가 결정 <br>
            int arr [5];<br>
            int * p = arr [0];<br>
            for(i = 0 ; i <5 ; i ++, p++)<br>
                printf (“&d ＼ n”, *p );
                <br>
                <h4>[2]포인터 배열 처리</h4>
                
                포인터 배열 : 주소를 저장하는 배열 <br>
                형식 : 데이터 타입 * 포인터 변수명[크기];<br>
                <div class="well">
                    * 배열명을 포인터 변수와 같이 연산에 의해 배열요소를 참조할 수있음<br>
                    * 포인터 변수에 증감 연산자를 이용하여 배열요소를 참조할 수 있음<br>
                    * 후위 증감 연산자가 , 전위 증감 연산자보다 우선순위가 높음<br>
                </div></p>
                
                
        2.gets()<br>
        <div class="well">
            * 공백을 포함한 문자열 입력<br>
            * char* gets(char * str);<br>
            * enter를 0’ 으로 변환하여 저장<br>
        </div>
        <h3>2) 문자열 표준 출력</h3>

        1.printf()<br>
        <div class="well">
            * 형식문자열 "%s"를 이용<br>
            * 문자 배열명을 printf함수의 첫번째 인자로 인식<br>
            * 함수 형식 : int scanf (“%s", str);<br>
        </div>
        1.pust()<br>
        <div class="well">
            * int puts(const char* str);<br>
            * str 배열의 문자열을 표준 출력에 출력<br>
            * 배열의 "\0"을 '\n'로 변환하여 출력<br>
        </div>







        초기화 : " "문자를 대입연산자에 이용<br>
        <ul>
            <li>값이 변경되지 않는 문자열  A나 “Hello World” 등 - 문자열 리터럴이라고도 함</li>
        </ul>
        문자열 변수
        <ul><li>•
            프로그램 수행 중에 변경될 수 있는 문자열 - 문자 배열</li>
            <li>배열의 크기는 상수로만 지정한다.</li>
        </ul>
        배열의 사용<br>
        <ul>
            <li>배열의 각 원소에 접근하려면 인덱스를 사용함</li>
            <li>인덱스는 항상 0~(배열의 크기-1)사이의 값임</li>
        </ul>
        배열의 초기화
        <ul><li>배열을 초기화하려면 {}안에 초기값을 나열함</li>
            <li>배열선언시 초기화할때는 배열의 크기를 생략할 수 있음</li>
            <li>필요시 2차원 이상의 배열 형태를 구현하는 것이 가능함</li>
            <li>실제 메모리 구조는 인접한 메모리의 연속임</li>
        </ul>
    </p><br>
    <h4>[2] 다차원 배열</h4>
    
    2차원 배열 : <br>
    <ul>
        <li>필요시 2차원 이상의 배열 형태를 구현하는 것이 가능함</li>
        <li>실제 메모리 구조는 인접한 메모리의 연속임</li></ul>
        
        
        
        <p data-ke-size="size16">
            함수 시작 시 생성되고 종료 시 소멸<br></p>
            <p data-ke-size="size16">
                생성 시 쓰레기값을 가짐<br>
                매개변수도 지역변수임<br>
                선언된 블록에서 유효</p>
                <br>
                <h3>전역변수</h3>
                <div class="well">
                    * 프로그램 내 전체 함수에서 유효, Global Variable<br>
                    * 프로그램 시작 시 생성, 데이터 영역에 생성<br>
                    * 프로그램 종료 시 소멸<br>
                    * 함수 밖에서 선언<br>
                    * 자동으로 0으로 초기화 <br>
                    * 전역변수는 프로그램 전체에서 참조하므로 복잡성을 증대<br>
                    * 모듈화의 독립성 확보가 어려움<br>
                    * 메모리 공간을 점유<br>
                </div>
                <h4>다중파일</h4>
                <p data-ke-size="size16">
                    extern을 선언하여 외부에서도 참조 가능<br>
                    extern int 변수; 외부에 선언된 변수를 참조한다는 선언문</p>
                    
                    
                </p>
                <h4>[1]함수 선언 및 호출</h4>
                <div class="well">
                    * 함수는 사용 전 반드시 선언해야 함<br>
                    * 선언은 함수의 원형(Prototype)을 기술함<br>
                    * 선언 시 매개변수 이름은 생략 가능함<br>
                    * 함수 호출 전에 정의문이 먼저 기술된 경우는 생략 가능함<br>
                </div>
                
                <p><p data-ke-size="size16"></p>
                int sub( int a, int b);<br>
                int sub( int, int);<br>
                
                <h4>호출</h4>
                sub (3, 7);  -> int sub(int a, int b) { ... }<br>
                * "," 로 구분하여 여러 개 전달 가능<br>
                * 매개변수가 없는 경우에는 void<br></p>
            </body>    
            </html>
            <ul>
                <li>문자열은 큰 따옴표 (“ 로 표현함</li>
                <li>문자열의 끝에는 널 문자 ＼ 0 를 함께 저장함</li></ul>
                <h3>용어</h3>
                <div class="well">
                    * 요소(elements) : 배열을 구성하는 각 항목<br>
                    * 배열(Array)명 : 전체 공간에 대한 대표 이름(변수명)<br>
                    * 크기 : 배열요소의 개수<br>
                    * 첨자(Index) : 각 요소에 부여되는 위치 정보<br>
                    </div></p>
                