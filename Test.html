<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열 포인터 처리</title>
    <style>
        .table {
            border: 1px solid #000;
            border-collapse: collapse;
        }

        .table tr th {
            margin: 5px;
            border: 1px solid #000;

        }

        .table tr td {
            border: 1px solid #000;
        }
    </style>
</head>

<body>
    <h2>애플리케이션 구현</h2><br>

    <h3>프로그램 설계</h3>

    <ul>
        <li>프로그램 개발 시 요구사항 분석 후 적절한 자료구조를 선택하는 것이 중요함</li>
        <li>다양한 데이터 타입을 묶어서 처리할 필요가 있는 경우 적절한 자료구조는 구조체임</li>
    </ul><br>
    <h3>헤더파일</h3>
    <pre class="line-numbers"><code class="language-js">
    #include <stdio.h>
    #define ST_NUM 20
    #define NAME_LENGTH 10

    typedef struct sungjuk {
            char name[NAME_LENGTH];
            int kor , eng ,mat;
            double avg;
    }SUNGJUK;

    int inScore (SUNGJUK* , int);
    void outScore (SUNGJUK* , int);
    void sortScore (SUNGJUK* , int);
</code></pre><br>
    <h3>main함수</h3>
    <pre class="line-numbers"><code class="language-js">
iut main()
{
        int sel, totalScnt=0;
        SUNGJUK student[ST_NUM];
        while(1){
                    put("|n원하는 메뉴를 선택하세요");
                    put("1. 성적입력");
                    put("2. 성적순출력");
                    put("0. 종료");
                    scanf("%d", &sel);
                    fflush(stdin);
                    switch(sel);
        }
}
</code></pre><br>
    <h3>입출력함수</h3>
    <pre class="line-numbers"><code class="language-js">
#include "scoreHeader.h"
int inScore(SUNGJUK * st, int cnt)
{
        char op;
        do{
                    fflush(stdin);
                    printf("\n이름:");
                    gets(st[cnt].name;
                    printf("국어:");
                    scanf("%d", &st[cnt].kor);
                    printf("영어:");
                    scanf("%d", &st[cnt].eng);
                    printf("수학":");
                    scanf("%d", &st[cnt].mat);
        }
}
</code></pre><br>

    <h3>코드분석</h3><br>
    <p data-ke-size="size18">

        <ul>
            <li>매크로 상수는 프로그램의 가독성을 높이고 유지보수를 편리하게 하는 장점이 있음</li>
            <li>사용자 정의 헤더파일은 ""를 이용하여 기술함.</li>
        </ul>

</body>

</html>

<div class="well">
    * 형식매개변수(Formal Parameter) : 함수 정의에서 기술되는 매개변수 목록<br>
    * 실매개변수(Real Parameter) : 함수 호출에서 기술되는 값, 인자(Argument)<br>
</div><br>
<p data-ke-size="size18">
    구조체가 가진 멤버를 비트 단위로 사용<br>
    비트 필드의 정의 : 멤버이름 + : + 비트 수 기술 <br>
    메모리에 할당할 때, 첫 번째 멤버를 최하위 비트에서부터 할당<br>
    비트필드의 멤버에 표현 가능한 범위 밖의 값을 저장하면 오버플로우가 발생<br>
    비트필드를 정희할 때는 중간에 일부 비트를 비워두고 멤버를 특정 비트에 할당할 수 있음 <br></p>


</p>
<p data-ke-size="size16">포인터 오류</p>
<p data-ke-size="size18"></p>
<ul>
    <li> 포인터도 변수이므로 반드시 초기화 해야 함</li>
    <li> 포인터 변수를 초기화하지 않고 사용하면 실행 에러가 발생함</li>
    <li> 널포인터: 포인터가 다른 변수를 가리키지 않을 때는 NULL(0)로 초기화함</li>
    <li> 포인터를 안전하게 사용하려면 우선 포인터가 널 포인터인지를 검사</li>
    <li> 포인터 변수의 데이터형이 반드시 포인터 변수가 가리키는 변수의 데이터형과 일치해야함</li>
</ul><br>


</ul>
<p data-ke-size="size16">배열의 시작 주소로 초기화된 포인터를 이용해서 배열의 모든 원소에 접근 가능 <br>
    포인터 변수를 배열 이름인 것처럼 사용 가능<br>
    포인터와 +,- 연산<br></p>
<div class="well">
    * p + N : p가 가리키는 데이터형 N개 크기만큼 증가된 주소가 연산의 결과<br>
    * p - N : p가 가리키는 데이터형 N개 크기만큼 감소된 주소가 연산의 결과<br>
</div>
</p>


<h4>[2]포인터와 배열 원소</h4>
<p>
    배열의 원소를 가리키는 포인터는 배열의 어떤 원소든지 가리킬 수 있음
    포인터가 배열의 원소가 아닌 일반 변수를 가리킬 때도 *(p+i) == p[1]는 항상 성립함
    <div class="well">
        * 배열과 포인터의 차이점 *<br>
        * 배열이 메모리에 할당되고 나면 , 배열의 시작 주소 변경 불가<br>
        * 포인터 변수는 값을 변경할 수 있으므로 , 포인터 변수에 보관된
        주소는 변경 가능<br>
    </div>
</p>


<ul>
    <li>포인터 배열은 주소를 보관하는 배열임</li>
    <li>포인터 배열을 이용하여 각 변수를 참조하는 것이 가능함</li>
    <li>여러 개의 문자열을 하나로 묶어 처리하는 방법으로 문자 포인터 배열을 이용할 수 있음</li>
</ul>




<p>
    <h3>포인터 이용</h3>
    <h4>[1]포인터 증감 연산</h4>

    포인터와++, 연산 : 포인터에대한 증감 연산 (++,--) 도 포인터형에 의해 연산의 결과가 결정 <br>
    int arr [5];<br>
    int * p = arr [0];<br>
    for(i = 0 ; i <5 ; i ++, p++)<br>
        printf (“&d ＼ n”, *p );
        <br>
        <h4>[2]포인터 배열 처리</h4>

        포인터 배열 : 주소를 저장하는 배열 <br>
        형식 : 데이터 타입 * 포인터 변수명[크기];<br>
        <div class="well">
            * 배열명을 포인터 변수와 같이 연산에 의해 배열요소를 참조할 수있음<br>
            * 포인터 변수에 증감 연산자를 이용하여 배열요소를 참조할 수 있음<br>
            * 후위 증감 연산자가 , 전위 증감 연산자보다 우선순위가 높음<br>
        </div>
</p>


2.gets()<br>
<div class="well">
    * 공백을 포함한 문자열 입력<br>
    * char* gets(char * str);<br>
    * enter를 0’ 으로 변환하여 저장<br>
</div>
<h3>2) 문자열 표준 출력</h3>

1.printf()<br>
<div class="well">
    * 형식문자열 "%s"를 이용<br>
    * 문자 배열명을 printf함수의 첫번째 인자로 인식<br>
    * 함수 형식 : int scanf (“%s", str);<br>
</div>
1.pust()<br>
<div class="well">
    * int puts(const char* str);<br>
    * str 배열의 문자열을 표준 출력에 출력<br>
    * 배열의 "\0"을 '\n'로 변환하여 출력<br>
</div>







초기화 : " "문자를 대입연산자에 이용<br>
<ul>
    <li>값이 변경되지 않는 문자열 A나 “Hello World” 등 - 문자열 리터럴이라고도 함</li>
</ul>
문자열 변수
<ul>
    <li>•
        프로그램 수행 중에 변경될 수 있는 문자열 - 문자 배열</li>
    <li>배열의 크기는 상수로만 지정한다.</li>
</ul>
배열의 사용<br>
<ul>
    <li>배열의 각 원소에 접근하려면 인덱스를 사용함</li>
    <li>인덱스는 항상 0~(배열의 크기-1)사이의 값임</li>
</ul>
배열의 초기화
<ul>
    <li>배열을 초기화하려면 {}안에 초기값을 나열함</li>
    <li>배열선언시 초기화할때는 배열의 크기를 생략할 수 있음</li>
    <li>필요시 2차원 이상의 배열 형태를 구현하는 것이 가능함</li>
    <li>실제 메모리 구조는 인접한 메모리의 연속임</li>
</ul>
</p><br>
<h4>[2] 다차원 배열</h4>

2차원 배열 : <br>
<ul>
    <li>필요시 2차원 이상의 배열 형태를 구현하는 것이 가능함</li>
    <li>실제 메모리 구조는 인접한 메모리의 연속임</li>
</ul>



<p data-ke-size="size16">
    함수 시작 시 생성되고 종료 시 소멸<br></p>
<p data-ke-size="size16">
    생성 시 쓰레기값을 가짐<br>
    매개변수도 지역변수임<br>
    선언된 블록에서 유효</p>
<br>
<h3>전역변수</h3>
<div class="well">
    * 프로그램 내 전체 함수에서 유효, Global Variable<br>
    * 프로그램 시작 시 생성, 데이터 영역에 생성<br>
    * 프로그램 종료 시 소멸<br>
    * 함수 밖에서 선언<br>
    * 자동으로 0으로 초기화 <br>
    * 전역변수는 프로그램 전체에서 참조하므로 복잡성을 증대<br>
    * 모듈화의 독립성 확보가 어려움<br>
    * 메모리 공간을 점유<br>
</div>
<h4>다중파일</h4>
<p data-ke-size="size16">
    extern을 선언하여 외부에서도 참조 가능<br>
    extern int 변수; 외부에 선언된 변수를 참조한다는 선언문</p>


</p>
<h4>[1]함수 선언 및 호출</h4>
<div class="well">
    * 함수는 사용 전 반드시 선언해야 함<br>
    * 선언은 함수의 원형(Prototype)을 기술함<br>
    * 선언 시 매개변수 이름은 생략 가능함<br>
    * 함수 호출 전에 정의문이 먼저 기술된 경우는 생략 가능함<br>
</div>

<p>
    <p data-ke-size="size16"></p>
    int sub( int a, int b);<br>
    int sub( int, int);<br>

    <h4>호출</h4>
    sub (3, 7); -> int sub(int a, int b) { ... }<br>
    * "," 로 구분하여 여러 개 전달 가능<br>
    * 매개변수가 없는 경우에는 void<br>
</p>
</body>

</html>
<ul>
    <li>문자열은 큰 따옴표 (“ 로 표현함</li>
    <li>문자열의 끝에는 널 문자 ＼ 0 를 함께 저장함</li>
</ul>
<h3>용어</h3>
<div class="well">
    * 요소(elements) : 배열을 구성하는 각 항목<br>
    * 배열(Array)명 : 전체 공간에 대한 대표 이름(변수명)<br>
    * 크기 : 배열요소의 개수<br>
    * 첨자(Index) : 각 요소에 부여되는 위치 정보<br>
</div>
</p>

div class="well">
형식<br>
* 기억부류 데이터형 변수명;<br>
* 기억부류 리턴형 함수명(매개변수 리스트);<br></div>

<h4>auto 변수</h4><br>
<p data-ke-size="size18">
    지역 변수는 디폴트로 auto 기억 부류를 사용<br>
    -> auto 지역 변수는 선언된 위치에서 자동으로 생성되고, 선언된 블록을 빠져나갈 때 자동으로 해제됨<br>
    전역 변수에는 auto 지정 불가능<br>
    for 루프에서 선언 시 루프 내에서만 통용<br></p>
<h4>register 변수</h4><br>
<ul>
    <li>변수를 메모리에 할당하는 대신 CPU의 레지스터에 할당</li>
    <li>변수를 레지스터에 할당하면 변수에 좀 더 빠르게 접근</li>
    <li>보통 루프 제어 변수를 레지스터 변수로 선언</li>
    <li>register 변수로 선언해도 변수가 레지스터에 할당되지 않을 수 있음</li>
    <li>레지스터 변수에 대해서는 주소 구하기 연산자를 사용할 수 없음</li>
</ul><br>
<h4>global 변수</h4><br>
<p data-ke-size="size18">
    다른 곳에 선언된 변수에 대하여 별도의 메모리 할당 없이 해당 변수를 사용<br>
    전역 변수를 코드 중간에 선언하면, 전역 변수가 선언된 뒤쪽에 정의된 함수에서만 전역 변수를 사용 가능<br>
    전방 선언(Forward Declaration) : <br>
    전역 변수에 대한 extern 선언이 있으면 전역 변수가 선언된 위치와 관계없이 전역 변수 사용 가능<br></p>

<h3>정적 변수</h3><br>
<h4>정적 지역 변수 : static</h4>
<ul>
    <li>번역 과정의 마지막 단꼐인 적재 시간에 기억 장소를 할당받는 변수</li>
    <li>전체 프로그램의 시작부터 종료까지를 생존 기간으로 하여 동일 기억 장소를 유지 </li>
    <li>초기화는 기억 공간 할당 시 한 번만 초기화됨</li>
    <li>정적 지역 변수는 전역 변수처럼 프로그램이 시작할 때 메모리에 할당되고 프로그램이 종료할 때 해체</li>
    <li>전역 변수와는 달리 정적 지역 변수는 선언된 함수 안에서만 사용</li>
    <li>정적 지역 변수는 함수가 리턴하더라도 해제되지 않고 남아있다가 그 다음 함수 호출 시 그대로 다시 이용</li>
</ul><br>
<h4>정적 전역 변수</h4><br>
<p data-ke-size="size18">
    정적 전역 변수는 정적 전역 변수가 선언된 소스 파일에서만 사용<br>
    정적 전역 변수는 전역 변수를 다른 소스 파일에서 접근하지 못하도록 제한<br><br>

    <table>
        <div>
            <tr>
                <th>구분</th>
                <th>일반 지역 변수</th>
                <th>정적 지역 변수</th>
                <th>전역 변수</th>
                <th>정적 전역 변수</th>
            </tr>
            <tr>
                <td>선언 위치</td>
                <td>함수 안</td>
                <td>함수 안</td>
                <td>함수 밖</td>
                <td>함수 밖</td>
            </tr>
            <tr>
                <td>생성 시점</td>
                <td>변수 선언 시</td>
                <td>프로그램 시작 시</td>
                <td>프로그램 시작 시</td>
                <td>프로그램 시작 시</td>
            </tr>
            <tr>
                <td>해제 시점</td>
                <td>함수 리턴 시</td>
                <td>프로그램 종료 시</td>
                <td>프로그램 종료 시</td>
                <td>프로그램 종료 시</td>
            </tr>
            <tr>
                <td>사용 범위</td>
                <td>함수 안</td>
                <td>함수 안</td>
                <td>프로그램 전체</td>
                <td>선언된 소스 파일</td>
            </tr>
            <tr>
                <td>초기화 하지 않았을 때</td>
                <td>쓰레기 값</td>
                <td>0으로 초기화</td>
                <td>0으로 초기화</td>
                <td>0으로 초기화</td>
            </tr>

        </div>
    </table><br>