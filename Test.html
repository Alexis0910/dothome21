<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>프로그래밍 언어별 특성</title>
    <style>
        .table {
            border: 1px solid #000;
            border-collapse: collapse;
        }

        .table tr th {
            margin: 5px;
            border: 1px solid #000;

        }

        .table tr td {
            border: 1px solid #000;
        }
    </style>
</head>
<body>
    <h2>게임 프로젝트</h2>
<h3>프로그램 설계</h3>
<p data-ke-size="size18">
제목 : 숫자 야구 게임 <BR>
요구사항:
<ul>
    <li>정답을 찾는데 소요된 시간과 횟수 출력</li>
    <li>랜덤함수를 이용하여 0~9 사이의 3 자리 정수 생성</li>
    <li>사용자 입력은 0~999 사이의 정수로 입력</li>
    <li>분할 컴파일이 가능하도록 다중 소스 파일 생성 </li>

<h4>주요 기능 구현</h4>
<div class="well">
* 컴퓨터 숫자 만들기 * <BR>
시드함수 SRAND와 랜덤함수 RAND를 이용한 3개의 랜덤값 생성<br>
rand() % 10<br><br>
* 소요 시간 연산 * <BR>
time함수를 이용하여 시작과 종료 시점의 시간을 추출<br>
difftime함수를 이용하여 시간차를 추가 연산에 의해 출력<br><br>
* 분할 컴파일 * <BR>
사용자 정의 헤더파일 생성<br>
배열 포인터를 함수의 매개변수로 전달<br>
</div><br>
<h4>헤더 파일</h4>

<pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <stdlib.h>

#define STRIKE 2
#define BALL 1

int* check(int*, int*);
voidmakeUserNum (int);
voidmakeComNum (int);
int tm_secDiff (time_t , time_t);
int tm_minDiff (time_t , time_t);
</code></pre><br>

<h4>랜덤값 생성</h4>

<pre class="line-numbers"><code class="language-js">
void makeComNum (int * com)
{
    int i;
    srand(time(NULL));
    for (i = 0; i < 3; i++)
    {
        com[i] = rand() % 10;
        printf(“ %d ”, com[i]);
    }
}
</code></pre><br>
<h4>소요시간 처리</h4>

<pre class="line-numbers"><code class="language-js">
int tm_minDiff (time_t end, time_t start)
{
    double  d_diff;
    d_diff = difftime (end,start);
    returnd_diff / 60;
}
inttm_secDiff time_t end, time_t start)
{
    int  tm_min;
    double d_diff;
    d_diff= difftime (end,start);
    tm_min = d_diff / 60;
    return d_diff --( tm_min *60 );
}
</code></pre><br>
<ul>
    <li>시간함수 관련 라이브러리를 이용하면 현재 시간 ,
        시간차이 등을 간단하게 얻을 수 있음</li>
    <li>랜덤값은 rand 함수를 이용하여 발생시킬 수 있음</li>
    <li>rand 함수는 랜덤값을 발생시키지만 실제로는 항상
        동일한 값을 발생시킴</li>
    <li>다른 랜덤값 생성을 위하여 랜덤함 수 호출 전 srand
        함수를 이용하여 다른 시드를 전달함</li>
</ul>


<h3>랜덤 함수</h3>
<h4>랜덤값 발생</h4>

<pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <string.h>

int main (void)
{
    int i;

    for(i =0; i<4; i++)
    {
        printf("%d %d\n", i, rand() % 100);
    }
    return 0;
}
</code></pre><br>

<h4>활용 예제</h4>
<p data-ke-size="size18">
1) 기능 : 학번에 따라 3개의 그룹으로 분류 <br>
2) 요구사항 : 10명의 학생을 학번에 따라 랜덤하게 3개의 그룹으로 분류(rand() % 3)<br>
<div class="well">
    * 랜덤값을 생성하는 라이브러리 함수 : rand<br>
    * rand함수는 실행 시 동일핚 랜덤값을 생성하므로 시드함수를 이용해야 함<br>
    * •rand함수 사용 시 시드함수로 srand가 있음<br>
    </div><br>

<h4>나이계산</h4>
<pre class="line-numbers"><code class="language-js">
int calAge(int birth){
    time_t timer;
    struct tm *t;

    timer = time(NULL);
    
    t = localtime(&timer);

    return t->tm_year + 1900- birth;
}
</code></pre><br>
>
<h4>이전 데이터 파일 쓰기</h4>
<pre class="line-numbers"><code class="language-js">
void savePhones(PHONE* mp, int cnt)
{ FILE * fp;
    int i;
    fp = fopen ("myPhones.bin" , "wb+");
    if (fp == NULL) perror ("Error opening file");
    else {
        fwrite(&cnt, sizeof(int), 1, fp);
            fwrite(mp, sizeof(PHONE), cnt, fp);
    fclose (fp); }
}
</code></pre><br>
<h4>이전 데이터 파일 읽기</h4>
<pre class="line-numbers"><code class="language-js">
PHONE* readPhones(PHONE* mp, int* cn)
{
    FILE * fp;
    int i,cnt;
    cnt = *cn;
    fp = fopen ("myPhones.bin" , "rb+");
    if (fp == NULL) perror ("Error opening file");
    else {
        fread(&cnt, sizeof(int),1,fp);
        mp = (PHONE*)realloc(mp,sizeof(PHONE)*(cnt+1));
        fread(mp, sizeof(PHONE), cnt, fp);
        fclose (fp);
}
    *cn = cnt;
    return mp;
}
</code></pre><br>
<h4>데이터 삭제</h4>
<pre class="line-numbers"><code class="language-js">
PHONE* deletePhone(PHONE* mp, int dn, int* cn) {
    int i,cnt;
    cnt = *cn;
    for(i=dn;i<cnt-1;i++)
            mp[i] = mp[i=1];
    *cn = cnt-1;
    return mp;
}
</code></pre><br>


<h3>localtime</h3>
<h3>asctime</h3>
<ul>
    <li>표준 출력 문장으로 많이 사용되는 함수 : printf ();</li>
    <li>두 시간 사이의 차이를 구하는 함수 : difftime</li>
    <li>현재 시스템의 시간을 구할 수 있는 함수 : time</li>
    <li>초 단위 시간을 시간문자열로 변환하는 함수 : ctime</li>
    <li>지역 시간을 구하는 함수 : localtime</li>
    <li>tm 구조체를 문자열로 변환하는 함수 : asctime</li>
</ul>

<h4>rewind</h4>
<h4>fprintf</h4>
    <p data-ke-size="size18">
        형식 문자열의 구조 : %[*] [width] [{h ¦ 1 ¦ L}]type<br>
</p>
<pre class="line-numbers"><code class="language-js">
#include <stdio.h>
int main ()
{
    FILE * pFile;
    int n;
    char name [100];

    pFile = fopen (“myfile.txt”, “w”);
    for (n=0 ; n<3 ; n++)
    {
        puts (“please, enter a name: ”);
        gets (name);
    fprintf (pFile, “Name %d [%-10.10s]\n”,n+1,name);
    }
    fclose (pFile);

    return
}
</code></pre><br>
<h3>이진 파일 입출력</h3>
<h4>fread</h4>
<pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <stdlib.h>
int main () {
    FILE * pFile;
    char buffer[500];
    size_t result;

    pFile = fopen ( “myfile.bin” , “rb” );
    if (pFile==NULL) {fputs (“File error”,stderr); exit (1);}

    fread (buffer,1,lSize,pFile);
        ………
    fclose (pFile);
    return 0;
}
</code></pre><br>

<h4>fwrite</h4>
<h4>fseek</h4>
<pre class="line-numbers"><code class="language-js">
#include <stdio.h>
int main ()
{
    FILE * pFile;
    pFile = fopen ( “example.txt” , “wb” );
    fputs ( "This is an apple." , pFile );
    fseek ( pFile , 9 , SEEK_SET );
    fputs ( " sam" , pFile );
    fclose ( pFile );
    return 0;
}
</code></pre><br>
<h4>ftell</h4>
<pre class="line-numbers"><code class="language-js">
int main( void)
{
    FILE *fp;
    char chr_byte;
    int ndx;

    fp = fopen( “./main.c”, “r”);

    for ( ndx = 0; ndx < 5; ndx++)
    {
    printf( “pointer = %d”, ftell( fp));
    printf( “ ”);
    printf( “char = %cn” , fgetc( fp));
    }

    fclose( fp);

    return 0;
}
</code></pre><br>

    <ul>
        <li>스트림 생성 : 파일 입출력을 위한 스트림을 생성, 파일 포인터, fopen</li>
        <li>입출력 : fgets, fgetc, fputs, fread, fwrite</li>
        <li>스트림 닫기 : fcloses</li>
    </ul>

    <h3>파일 입출력 함수</h3>
    <p data-ke-size="size18">
        [1]파일 입출력을 수행하려면 먼저 fpoen 함수를 이용하여 파일을 열어야 함<br>
        [2]fopen 함수의 원형<br>
        FILE *fopen (const char *filename, const char *mode);<br>
        <div class="well">
            filename : 파일이름<BR>
            mdode : 파일 열기 모드<br>
            리턴 값 : 생성된 파일 스트림의 파일 포인터를 리턴, 파일을 열 수 없으면 널 포인터를 리턴<br>
        </div><br>
        [3]디폴트 모드는 텍스트 파일
        <ul>
            <li>파일로부터의 입력 함수로는 fgetc , fgets , fscanf , fread
                등이 있음</li>
            <li>파일에 출력하는 함수는 fputc , fputs , fprintf , fwrite
                등이 있음</li>
            <li>파일의 끝을 판단하는 함수는 feof 가 있음</li>
        </ul></p>
        <h5>fgetc, fputc</h5>
    <p data-ke-size="size18">
파일로부터 문자 하나를 입력받거나 출력할 때 사용됨 : <br>
int fgetc(FILE *stream);<br>
int fputc(int c, FILE *fp)<br></p>
<pre class="line-numbers"><code class="language-js">
#include <stdio.h>
int main( void)
{
    FILE *fp;
    char  ch;
    if (fp = fopen ("./main.c”, “r"))
    {
        while( EOF != (ch = fgetc ( fp )))
            putchar( ch );
        fclose( fp )
    }
    return 0;
}
</code></pre><br>
<h5>fgets, fputs</h5>
<p data-ke-size="size18">
파일로부터 한 줄의 문자열을 입력받거나 출력할 때 사용 <br>
char *fgets(char *str, int n, FILE *stream);<br>
int fputs(const char *str, FILE *fp)<br></p>
fgets<br>
fputs<br>
<pre class="line-numbers"><code class="language-js">
#include <stdio.h>
int main( void)
{
    FILE *fp_sour
    FILE *fp_dest
    char *buf
    intbuf_size ;
    buf_size = 1024;

if (fp_sour = fopen ( "./main.c ”, “i"))
    {
        if (fp_dest = fopen ( "./backup.c ”, “w"))
        {
            buf = malloc ( buf_size+5 );
            while(fgets ( buf , buf_size , fp_sour ))
                fputs( buf , fp_dest );
            free(buf);
            fclose( fp_dest );
        }
        fclose( fp_sour );
    }
    return 0;
}
</code></pre><br>
<h4>기타 함수</h4>
<p data-ke-size="size18">
[1]ferror 함수 <br>
:파일 입출력 시 발생하는 에러를 확인<br>
    <div class="well">
        int ferror(FILE *stream);<BR>
        * 리턴 값:<br>
        스트림에 에러가 발생했으면 0이 아닌 값을 리턴<br>
        에러가 발생하지 않았으면 0을 리턴<br>
    </div><br>
</p>
<p data-ke-size="size18">
    [2]feof 함수 <br>
    :파일의 끝인지를 검사<br>
        <div class="well">
            int feof(FILE *stream);<BR>
            * 리턴 값:<br>
            읽는 위치가 파일의 끝이면 0이 아닌 값을 리턴<br>
            읽는 위치가 파일의 끝이 아니면 0을 리턴<br>
        </div><br>
    </p>

    <h4>자료구조 정의</h4>

    <div class="well">
        struct book {<br>
            char bookTitle[50];<br>
            char bookAuthor[20];<br>
            int bookPrice;<br>
            int bookSale;<br>
            char bookCode[8];<br>
            };
    </div><br>
<h3>코드 분석</h3>
<ul>
    <li>strtok는 토큰을 이용하여 문자열을 분리할 수 있는 함수임</li>
    <li>strcspn은 특정 문자로 이루어진 문자열인지 검사하는 것이 가능한 함수임</li>
    <li>strstr은 키워드 검색에 유용한 함수임</li>
</ul>
<h4>동적 할당</h4>

<pre class="line-numbers"><code class="language-js">
BOOK*inBook(BOOK* mb, int*cn)
{
    char yn;
    int number;
    int cnt;
    cnt = *cn;
    do{
        while(1){
            mb = (BOOK*) realloc(mb, sizeof(BOOK)*(cnt+2));
        }while(yn =='y');
        *cn = cnt;
        return mb;
}
</code></pre><br>
<h4>베스트셀러 출력</h4>
<pre class="line-numbers"><code class="language-js">
cae 3: 
    qsort(mb, cnt+1, sizeof(BOOK),compare);

    printf("\n-----------------\n");
    printf("n------BestSEller Top3------");
    printf("\n-----------------\n");
    for (int i=0; i<3; i++)
    {
        printf("Top %d : %30s Sale: %d\n", i+1, mb[i].bookTitle, mb[i].bookSale);
    }

    printf("\n-----------------\n");
    break;
    int compare(cons void*a, const void *b)
    {
        BOOK * ptr_a =(BOOK *)a;
        BOOK * ptr_b =(BOOK *)b;

        if (ptr_a ->booksale == ptr_b ->bookSale) return 0;
        else return -1;
    }
}
</code></pre><br>


    <p data-ke-size="size18">[1]리턴과 매개변수가 없는 함수에 대한 함수 포인터</p>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h> 
void hello()
{
    printf(“Hello, world!\n”);
}

void good()
{
    printf(“Good morning!\n”); 
}
int main()
{
    void(*fp)();

    fp = hello;
    fp();

    fp = good;
    fp();

    return 0;
}
</code></pre><br>
<p data-ke-size="size18">[2]리턴과 매개변수가 있는 함수에 대한 함수 포인터</p>
<pre class="line-numbers"><code class="language-js">
#include <stdio.h> 
int add(int a, int b)
{
    return a + b;
}

int sub(int a, int b)
{
    return a - b;
}

int main()
{
    int(*fp)(int, int);

    fp = add;
    printf("%d\n", fp(10, 20));

    fp = sub;
    printf("%d\n", fp(10, 20));
    
    return 0;
}
</code></pre><br>
<p data-ke-size="size18">[3]함수 포인터 배열</p>
<pre class="line-numbers"><code class="language-js">
#include <stdio.h> 
int add(int a, int b)
{
    return a + b;
}

int sub(int a, int b)
{
    return a - b;
}
7
함수 포인터
함수 포인터 이해
함수 포인터 형식
2
함수 포인터 배열
3
#include <stdio.h>
int add(int a, int b)
{
return a + b;
}
int sub(int a, int b)
{
return a - b;
}

int main()
{
    int funcNumber;
    int num1, num2;
    int (*fp)(int, int) = NULL;

    printf(“함수 번호와 계산할 값을 입력하세요: ”);
    scanf(“%d %d %d”, &funcNumber, &num1, &num2);

    switch (funcNumber) {
    case 1:
        fp = add;
        break;
    case 2:
        fp = sub;
        break; 
    }

    printf(“%d\n”, fp(num1, num2));
    return 0; }

</code></pre><br>
<p data-ke-size="size18">[4]구조체 멤버</p>
<pre class="line-numbers"><code class="language-js">
#include <stdio.h>

struct Calc {
    int (*fp)(int, int);
};
int add(int a, int b)
{
    return a + b;
}
*구조체가 함수를 포함하는 형태로 구현 가능*
</code></pre><br>
<p data-ke-size="size18">[5]함수의 매개변수</p>
<pre class="line-numbers"><code class="language-js">
#include <stdio.h>
int add(int a, int b)
{
    return a + b;
}
void calc(int (*fp)(int, int))
{
    printf(“%d\n”, fp(10, 20));
}
int main()
{
    calc(add);
    return 0;
}
</code></pre><br>
<h3>함수 포인터 활용</h3>
<h4>qsort()</h4>
<ul>
    <li>qsort는 stdlib.h를 include 해야 함</li>
    <li>qsort는 테이블의 자료를 퀵정렬하는 함수임</li>
    <li>비교함수는 처리할 자료형에 맞게 직접 구현해야 함</li>
</ul>
<pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <stdlib.h>

int values[] = { 40, 10, 100, 90, 20, 25 };
int compare (const void * a, const void * b)
{
    return ( *(int*)a - *(int*)b );
}
int main ()
{
    int n;
    qsort (values, 6, sizeof(int), compare);
    for (n=0; n<6; n++)
        printf (“%d ”,values[n]);
    return 0;
}
</code></pre><br>




<pre class="line-numbers"><code class="language-js">
함수활용
#include <stdio.h>
#include <stdlib.h>
int main()
{
    char *a, str[20];
    a = (char *)calloc(1,1);
    if (a == NULL) printf(“Fail Allocation”);
    while(1){
        gets(str);
        if( !strcmp(str,“end”) )
            break;
        a = (char *)realloc(a,strlen(str)+1);
        strcat(a,str);
    }
    printf(“\n%s”, a);
    free(a);
    return 0;
}
</code></pre><br>


    <h4>선언부</h4>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <string.h>
typedef struct book{
    char bookTitle [50];
    char bookAuthor [20];
    intbookPrice;
    intbookSale;
    charbookCode [ 9];// xxxx
xxx 북코드
}BOOK;
int inBook (BOOK* , int);
void outBook (BOOK* , int);
void searchBook (BOOK* , int);
</code></pre><br>
<h4>코드입력 검증</h4>
<pre class="line-numbers"><code class="language-js">
int inBook (BOOK* mb , int cnt)
{
    int number;
    while(1){
        printf("\n책코드 :");
        gets(mb [cnt] .bookCode);
        if (strlen mb [cnt] bookCode ) == 8
        {
            number = strcspn ( cnt bookCode , "0123456789-");"
            if (number==8 && number != 0)
                    break;
        }
</code></pre><br>
<h4>연도별 출력</h4>
<pre class="line-numbers"><code class="language-js">
printf("\n 검색할 출판연도를 입력하세요 : ”);
gets(sKey);
printf("\n----------------------");
printf("n%10s %30s n”, “ 코 드 ”, 제 목");
for(i =0; i<cnt; i++)
{
    year = strtok mb [i] .bookCode,"-");
    if (!strcmp year,sKey))
    {
printf("\n%10s %30s”,mb[i].bookCode , mb[i].bookTitle);
        check++;
    }
}
if(check == 0)
{
    printf("\n 일치하는 책이 없습니다 . \n”);
}
</code></pre><br>

<h4>키워드 검색</h4>
<pre class="line-numbers"><code class="language-js">
printf("\n 검색할 제목을 입력하세요 :");
gets( sTitle );
for(i=0;i<cnt; i++)
{
    if (strstr mb[i].bookTitle,sTitle )!=NULL)
    {
    printf("\n\n----------------------");
    printf("\n코 드 : %s n”, mb [i]. bookCode);
    printf("제 목 : %s n”, mb [i]. bookTitle);
    printf("저 자 : %s n”, mb [i]. bookAuthor);
    printf("가 격 : %d n”, mb [i]. bookPrice);
    printf("판매수량 : %d n”, mb [i]. bookSale);
    check++;
    }
}
if(check)
    {
        printf("\n------------------------");
        printf("\검색 건수 : %d\n”, check);
    }
    else
{
        printf("\n------------------------");
        printf("\n 일치하는 책이 없습니다 .\n”);
}
</code></pre><br>


    <p data-ke-size="size18">
        [2]검색함수<br></p>
    <ul>
        <li>memchr : 메모리 블록에서 문자열 검색</li>
        <li>strchr : 문자열에서 찾는 문자의 첫 번째 위치</li>
        <li>strrchr : 문자열의 마지막에서부터 문자 위치 검색</li>
        <li>strspn : 문자열에서 특정 문자로 구성된 문자열의 길이</li>
        <li>strcspn : 문자열에서 특정 문자로 구성에 포함되지 않는 문자열의 길이</li>
        <li>strstr : 부분 문자열 위치</li>
        <li>strspn : 토큰으로 문자열 분리</li>
    </ul>
    <h4>문자열 비교함수</h4>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <string.h>
int main ()
{
    char buffer1[] = "DWgaOtP12df0";
    char buffer2[] = "DWGAOTP12DF0";
    int n;
    n=memcmp ( buffer1, buffer2, sizeof(buffer1) );
    if (n>0) printf ("‘%s’ is greater than ‘%s’.\n",buffer1,buffer2);
    else if (n<0) printf ("‘%s’ is less than ‘%s’.\n",buffer1,buffer2);
    else printf ("‘%s’ is the same as ‘%s’.\n",buffer1,buffer2);

    return 0;
}
</code></pre><br>
    <h4>strcmp</h4>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <string.h>
int main( void)
{
    char str_apple[] = "apple";
    char str_apple2[] = " apple";
    char str_banana[] = "banana";
    char str_appleII[]= "appleII";
printf( "%s with %s = %d\n", str_apple, str_apple , strcmp( str_apple, str_apple ) );
printf( "%s with %s = %d\n", str_apple, str_apple2 , strcmp( str_apple, str_apple2 ) );
printf( "%s with %s = %d\n", str_apple, str_banana , strcmp( str_apple, str_banana ) );
printf( "%s with %s = %d\n", str_apple, str_appleII, strcmp( str_apple, str_appleII) );
return 0;
}

</code></pre><br>
    <h4>strncmp</h4>
    <pre class="line-numbers"><code class="language-js">
int main ()
{
    char str[][5] = { "R2D2" , "C3PO" , "R2A6" };
    int n;
    puts ("Looking for R2 astromech droids... ");
    for (n=0 ; n<3 ; n++)
    if (strncmp (str[n], ‚R2xx‛,2) == 0)
    {
        printf ("found %s\n",str[n]);
    }
    return 0;
}
</code></pre><br>
    <h3>문자열 검색함수</h3>
    <h4>memchr</h4>
    <pre class="line-numbers"><code class="language-js">
int main ()
{
    char * pch;
    char str[] = "Example string";
    pch = (char*) memchr (str, ‘p’, strlen(str));
    if (pch!=NULL)
        printf "‚ ‘p’ found at position %d.\n", pch-str+1);
    else
        printf (" ‘p’ not found.\n");
    return 0;
}
    </code></pre><br>

    <h4>strchr</h4>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <string.h>
int main( void)
{
    char *str = "www.abcd.com";
    printf( "%s\n", strchr( str, ‘a’));
    return 0;
}
</code></pre><br>
    <h4>strrchr</h4>
    <pre class="line-numbers"><code class="language-js">
int main( void)
{
    char *str = "www.world.com";
    printf("‚%s\n", strrchr( str, ‘w’));
    return 0;
}
</code></pre><br>
    <h4>strspn</h4>
    strspn(str, "bdca");<br>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <string.h>
int main ()
{
    int i;
    char strtext[] = "129th";
    char cset[] ="‚1234567890";
    i = strspn (strtext,cset);
    printf ("The initial number has %d digits.\n",i);
    return 0;
} 
</code></pre><br>

    <h4>strcspn</h4>

    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <string.h>
int main ()
{
    char str[] = "fcba73";
    char keys[] = "1234567890";
    int i;
    i = strcspn (str,keys);
    printf ("The first number in str is at position %d.\n",i+1);
    return 0;
}
</code></pre><br>
    <h4>strstr</h4>
    strstr(str, ‚morning‛);<br>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <string.h>
int main ()
{
    char str[] ="This is a simple string";
    char * pch;
    ch = strstr (str,"simple");
    sptrncpy (pch,"sample",6);
    puts (str);
    eeturn 0;
}
</code></pre><br>
    <h4>strtok</h4>
    strtok(str , del);<br>
    strtok(NULL, del);<br>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <string.h>
int main ()
{
    char str[] ="010-1234-5678";
    char * pch;
    printf ("Splitting string \‚%s\" into tokens:\n‛,str);
    pch = strtok (str,"-");
while (pch != NULL)
    {
        printf ("%s\n",pch);
        pch = strtok (NULL, ".-");
    }
    return 0;
}
</code></pre><br>

    <p data-ke-size="size18">
        [3]지수, 로그 함수<br></p>
    <ul>
        <li>pow : 거듭제곱 연산</li>
        <li>sqrt : 거듭제곱근 연산</li>
    </ul>
    <p data-ke-size="size18">
        [4]반올림함수<br></p>
    <ul>
        <li>ceil : 올림연산</li>
        <li>round : 반올림 연산</li>
        <li>floor : 내림연산</li>
    </ul>
    [5]최대값.최소값 함수<br></p>
    <ul>
        <li>fmax : 매개변수 중 최대값 반환</li>
        <li>fmin : 매개변수 중 최소값 반환</li>
    </ul>
    [6]절대값 함수<br></p>
    <ul>
        <li>abs : 정수의 절대값 연산</li>
        <li>fabs : 실수의 절대값 연산</li>
    </ul>
    <h3>삼각함수</h3>
    <div class="well">
        함수 원형<br>
        double sin (double x);<br>
        float sinf (float x);<br>
        long double sinl (long double x);<br><br>

        double cos (double x);<br>
        float cosf (float x);<br>
        long double cosl (long double x);<br>
        매개변수의 해당 삼각함수 값을 리턴<br>
        매개변수는 radian 값<br>
        radian value = degree PI/180<br>
    </div>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <math.h>

#define PI 3.14159265
int main ()
{
    double param ,result;
    float paramf,resultf;
    param = 30.0;
    result = sin ( param * PI/180);
    printf ("The sine of %f degrees is %f.\n", param , result);
    param = 60.0;
    result = cos ( param PI / 180 );
    printf ("The cosine of %f degrees is % n", param , result);

    paramf = 30.0;
    resultf = sinf paramf PI/180);
    printf("The sine of %f degrees is % n", paramf , resultf);
    return 0;
}
</code></pre><br>
    <h4>지수 로그함수</h4>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <math.h>

int main ()
{
    double param ,result;

    param = 5.0;
    result = exp( param );
    printf("The exponential value of %f is %f.\n", param , result);
    param = 1000.0;
    result = log10 ( param )
    printf ("log10(%f) = %f\n", param , result);

    param = 5.5;
    result = log10( param );
    printf("log(%f) = %f\n", param , result);
    return 0;
}
    </code></pre><br>
    <h4>제곱함수</h4>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <math.h>
int main ()
{
    printf ("7 ^ 3 = %f\n", pow (7.0, 3.0) );
    printf("4.73 ^ 12 = %f\n", pow (4.73, 12.0) );
    printf ("32.01 ^ 1.54 = %f\n", pow (32.01, 1.54) );

    double param ,result;
    param = 1024.0;
    result = sqrt (param);
    printf ("sqrt (%f) = %f\n", param , result);
    return 0;
}
</code></pre><br>
    <h4>반올림함수</h4>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <math.h>
int main ()
{
    printf( "ceil of 2.3 is %.1f\n", ceil(2.3) );
    printf( "ceil of 3.8 is %.1f\n", ceil(3.8) );
    printf( "ceil of 2.3 is %.1f\n", ceil( 2.3) );
    printf( "ceil of 3.8 is %.1f\n", ceil( 3.8) );
    return 0;
}
</code></pre><br>
    <h4>절대값함수</h4>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h >
#include <math.h>
int main ()
{
    printf("The absolute value of 3 is %f\n", abs (3) );
    printf("The absolute value of 10 is %f\n", abs ( 10) );
    printf("The absolute value of 3.1416 is %f\n", fabs (3.1416)
    printf("The absolute value of 10.6 is %f\n", fabs 10.6) );
    return 0;
}
</code></pre><br>
    <p data-ke-size="size18">
        •삼각함수는 매개변수로 라디안 값을 전달해야 함<br>
        •라디안 값 : degree PI/180<br>
        •지수함수의 기본함수 : exp<br>
        •반올림함수 외에 올림 , 내림을 수행하는 함수도 있음<br>
        •C 언어에서 절대값은 정수와 실수 매개변수에 따라<br>
        구분되어 사용<br>
    </p>

    <h4>자료 구조 정의</h4>
    <table>
        <div>
            <tr>
                <th rowspan="4">자료</th>
                <th>도서명</th>
                <th>char</th>
                <th>bookTitle</th>
            </tr>
            <tr>
                <th>저자</th>
                <th>char</th>
                <th>bookAuthor</th>
            </tr>
            <tr>
                <th>가격</th>
                <th>int</th>
                <th>bookPrice</th>
            </tr>
            <tr>
                <th>판매수량</th>
                <th>int</th>
                <th>bookSale</th>
            </tr>
            <tr>
                <td>요구사항</td>
                <td colspan="3">struct book { <br>
                    char bookTitle[50];<br>
                    char bookAuthor[20];<br>
                    int bookPrice;<br>
                    int bookSale;<br>
                    };</td>
            </tr>
        </div>
    </table>
    <h3>코드 분석</h3>
    <h4>선언부</h4>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
#include <string.h>

typedef struct book{
    char bookTitle[50];
    char bookAuthor[20];
    int bookPrice;
    int bookSale;
}BOOK;
int inBook(BOOK* , int);
void outBook(BOOK* , int);
void searchBook(BOOK* , int);
</code></pre><br>
    <h4>main() 함수</h4>
    <pre class="line-numbers"><code class="language-js">
int main()
{
    int sel, totalBCnt=0;
    BOOK myBook[100];
    while(1){
        puts("\n원하는 메뉴를 선택하세요");
        puts("1. 도서 입력");
        puts("2. 도서 출력");
        puts("3. 도서 검색");
        puts("0. 종료 ");
        scanf("%d", &sel);
        fflush(stdin);
        switch(sel){
        case 1 : totalBCnt = inBook(myBook, totalBCnt);
        break; 
        case 2 : outBook(myBook, totalBCnt); 
        break; 
        case 3 : searchBook(myBook, totalBCnt); 
        break; 
        case 0 : 
        return 0; 
        default : puts("0~3 사이의 메뉴 번호를 선택하세요");
        }
    } 
    return 0; 
}
</code></pre><br>

    <h4>입력함수</h4>
    <pre class="line-numbers"><code class="language-js">
int inBook(BOOK* mb, int cnt)
{
    printf("\n책제목 : ");
    gets(mb[cnt].bookTitle);
    printf("저자 : ");
    gets(mb[cnt].bookAuthor);
    printf("가격 : ");
    scanf("%d",&mb[cnt].bookPrice);
    printf("재고수량 : ");
    scanf("%d",&mb[cnt].bookSale);
    return ++cnt;
}
</code></pre><br>

    <h4>출력함수</h4>
    <pre class="line-numbers"><code class="language-js">
void outBook(BOOK* mb, int cnt)
{
    int i;
    for(i=0;i<cnt;i++)
    {
        printf("\n-----------------------------------");
        printf("\n제목 : %s \n",mb[i].bookTitle);
        printf("저자 : %s \n",mb[i].bookAuthor);
        printf("가격 : %d \n",mb[i].bookPrice);
        printf("수량 : %d \n",mb[i].bookSale);
    }
}
</code></pre><br>

    <h4>검색함수</h4>
    <pre class="line-numbers"><code class="language-js">
void searchBook(BOOK* mb, int cnt)
{
    char sTitle[50];
    int i, search;
    puts("\n원하는 메뉴를 선택하세요");
    puts("1. 제목 검색 ");
    puts("2. 저자 검색 ");
    scanf("%d", &search);
    fflush(stdin);
    switch(search){
        case 1 : printf("\n검색할 제목을 입력하세요: ");
            gets(sTitle);
            for(i=0;i<cnt;i++)
            {
            }
</code></pre><br>
    <div class="well">
        int getc (FILE *stream );<br>
        * 지정한 스트림으로 부터 문자 읽기<br>
        * 입력문자 ASCII 코드 값을 리턴 , 오류 시는 EOF 리턴<br><br>
        int putc (int ch, FILE *stream );<br>
        * 지정한 스트림에 지정한 값을 출력<br>
        * 정상 출력시 출력문자 리턴, 오류 시는 EOF리턴<BR>
    </div>
    <h4>_getch() _getche() _putch()</h4>
    int_getch(void); int_getche (void); : 키보드로부터 입력되는 문자를 읽음, 입력 문자의 ASCII 코드를 리턴,버퍼를 사용하지 않는 입력<br>
    int_putch (int ch); : 화면에 지정한 값을 출력,정상 출력 시 출력문자 리턴 , 오류 시 EOF 리턴<br>
    <h4>getchar() putchar()</h4>
    int getchar (void);<br>
    •키보드로부터 입력되는 문자를 읽음<br>
    •입력 문자의 ASCII 코드를 리턴<br>
    •버퍼를 사용하는 입력<br><br>
    int putchar(int ch);<br>
    •화면에 지정한 값을 출력<br>
    •정상 출력 시 출력문자 리턴 , 오류 시 EOF 리턴<br><br>
    <h4>gets() gets_s() puts()</h4>
    char *gets(char *str); char*hets_s(char *str, rsize_tn);<br>
    •키보드로부터 입력되는 문자들을 \n까지 읽어서 str에 입력<br>
    •"\n"을 null로 변환하여 저장<br><br>
    int puts(char *str);<br>
    •화면에 지정한 문자열을 출력<br>
    •null(\0)을 \n으로 변환하여 출력<br>
    •정상 출력시 음수가 아닌 값을 리턴, 오류 시 EOF 리턴<br><br>
    </p>
    <pre class="line-numbers"><code class="language-js">
#include <stdio.h>
int main()
{
    char a[5];
    gets(a);
    puts(a);
    return 0;
}
</code></pre><br>
    <h3>문자 문자열 처리함수</h3>


    <h4>문자, 문자열 처리 관련 라이브러리</h4>
    <ul>
        <li>헤더파일 : ctype.h string.h</li>
        <li>http://en.cppreference.com/w/c/string/byte</li>
        <li>isalpha(), islower , isupper()</li>
        <li>strlen(), strcpy(), strcmp()</li>
    </ul>
    <div class="well">
        [1] isalpha<BR>
        * if( (‘A’<=ch && ‘Z'>= ch ) || (‘a' <=ch && ‘z'>= ch ) )<br>
                * int isalpha (int ch);<br>
                * 헤더파일 : ctype.h<br>
                * 인수가 알파벳 문자인지를 확인<br>
                * 알파베문자이면 0이아닌 값을 리턴<br>
                * 알파베문자가 아니면 0값을 리턴<br>
    </div><br>
    <div class="well">
        [2] islower() isupper()<BR>
        * 헤더파일 : ctype.h<br>
        * int islower (int ch) : 인수의 문자가 소문자이면 0이 아닌값, 그 외이면 0을 리턴<br>
        * int isupper (int ch) : 인수의 문자가 대문자이면 0이 아닌값, 그외이면 0을 리턴<br>
    </div><br>
    <div class="well">
        [3] strlen()<BR>
        * 헤더파일 : strin.h<br>
        * size_t strlen (const char *str);<br>
        * 문자열에서 null 전까지의 길이를 리턴<br>
    </div><br>
    <div class="well">
        [4] strcpy()<BR>
        * char strcpy (char *dest, const char *src);<br>
        * null문자를 포함하여 src 의 문자열을 dest 로 복사<br>
        * src문자열의 길이가 dest 문자 배열의 크기보다 크면 실행 에러가 발생할 수 있 -음<br>
        * error_t *strcpy_s (char *dest, sizt_t sizedest ,const char *src);<br>
        * 함수 성공 시 0, 그 외 오류번호를 리턴<br>
        * src문자열의 길이가 dest 문자 배열의 크기보다 크면 실행 에러가 발생할 수 있 음<br>
    </div><br>
    <div class="well">
        [5] strcmp()<BR>
        * 헤더파일 : strin.h<br>
        * int strcmp (const char *lhs, const char *rhs);<br>
        * null 문자 전까지 각 뭊자를 비교<br>
        * 동일하면 0을 리턴<br>
        * lhs가 크며 양수, rhs가 크면 음수를 리턴<br>

    </div><br>


    <h4>C표준 라이브러리</h4>
    <h5>*구조체는 포인터로 전달*</h5>
    <pre class="line-numbers"><code class="language-js">
/*
sqrt example */
#include < stdio.h > /* printf
#include < math.h > /* sqrt

int main ()
{
    double param , result;
    param = 1024.0;
    result = sqrt (param); 
    printf("sqrt (%f) = %fn”, param ,
result );
    return 0;
}
</code></pre><br>
    <h4>Visual Studio에서 만들기</h4>
    <ul>
        <li>정적 라이브러리 프로젝트로 생성</li>
        <li>헤더파일과 소스코드를 작성</li>
        <li>lib 빌드</li>
    </ul>
    <h4>DEV C++에서 만들기</h4>
    <ul>
        <li>정적 라이브러리 프로젝트로 생성</li>
        <li>헤더파일과 소스코드를 작성</li>
        <li>오브젝트 파일 생성</li>
        <li>.a 파일 생성</li>
    </ul>


    <h5>*바이트(Byte) 이상의 데이터는 포인터로 전달*</h5>
    <pre class="line-numbers"><code class="language-js">
void sub( double m1, double m2 )
{
    ……
}
int main()
{
    double im, si ;
    ……
    ……
    sub( im, si );
    ……
}
</code></pre><br>
    <h5>*여러 개의 매개변수를 구조체로 전달*</h5>
    <pre class="line-numbers"><code class="language-js">
struct test {
    int a,b;
    double c;
};
void sub( double o, double p, double q, double r, double s )
{
    ……
}
int main()
{
    double a,b,c,d,e;
    struct test im;
    ……
    ……
    sub( a,b,c,d,e);
    ……
}
</code></pre><br>

    <h5>*연산의 최적화 - 실수 연산을 최소화(정수의 연산으로)*</h5>
    <pre class="line-numbers"><code class="language-js">
int main()
{
    double a=5.0, b=3.0, c;
    double d=15.34, e=3.0, f;
    c = a * b;
    f = d * e;
}
int main()
{
    int p,q,r;
    double a=5.0, b=3.0, c;
    double d=15.34, e=3.0, f;
    p = a;
    q= b;
    r = p * q;

    p = d * 100; // 소수점 이하 2자리의 배정도
    q = e * 100;
    f = ( p * q )/100;
}

    <h3>디버거(Debugger)/h3>
        <p data-ke-size="size18">
            디버깅을 수행하는 프로그램 : Visual Studio, Code Blocks<br>
            대부분의 IDE는 디버거를 내장<br>
        </p>
        <ul>
            <li>변수값 추적</li>
            <li>중단점 지정</li>
            <li>모듈 단위 실행</li>

        </ul><br>
        <h4>Visual Studio Debugging</h4>
        <p data-ke-size="size18">
            디버깅 순서<BR>
            1. 프로그램 오류가 발생한 곳이라고 의심되는 부분에 중단점을 설정하기<br>
            2. ‘디버깅 시작’ 누르기<br>
            3. 프로그램이 실행되다가 중단점을 만나면 그 부분에서 멈추기<br>
            4. ‘F11’키로 한 줄씩 실행하면서 아래 ‘자동’창의 변수값 확인 및 오류 찾기<br>
            5. ‘Shift + F5’로 디버깅을 종료하고 오류 수정하기<br>
        </p>
        <h4>DEV C++ Debugging</h4>
        <div class="well">
            디버깅 순서<BR>
            * 프로그램 오류가 발생한 곳이라고 의심되는 부분에 중단점을 설정하기<br>
            * [debug] 탭에서 ‘debug’를 클릭하기<br>
            * 프로그램이 실행되다가 중단점을 만나면 그 부분에서 멈추기<br>
            * ‘F7’키로 한 줄씩 실행하면서 변수값 확인 및 프로그램 실행 화면에서 오류 찾기<br>
            * [Stop Execution] 버튼을 눌러 디버깅 종류 및 오류 수정<br>
        </div><br>
        <h4>Code Blocks Debugging</h4>

        <div class="well">
            * 프로그램 오류가 발생한 곳이라고 의심되는 부분에 중단점을 설정하기<br>
            * [debug]탭에서 [start], [step into] 클릭하기<br>
            * 로그램이 실행되다가 중단점을 만나면 그 부분에서 멈추기<br>
            * ‘F7’키로 한 줄씩 실행하면서 프로그램이 실행된 화면에서 오류 찾기<br>
            * 변수 추적은 [debug]의 [debugging windows]-[watches]를 열어서 확인<br>
            * [stop debugging] 버튼을 눌러서 디버깅을 종료하고 오류를 수정<br>
        </div><br>

        <h3>컴퓨터 언어 종류</h3>
        <h4>C</h4>
        <p data-ke-size="size18">
            1. 어셈블리어와 고급 언어의 장점을 가지고 있음 <br>
            2. 작고 빠른 프로그램<br>
            3. 뛰어난 이식성<br>
            4. 컴파일러 언어<br>
        </p>
        <div class="well">
            특징 :<BR>
            * 하드웨어 제어<br>
            * 범용 프로그래밍<br>
            * 효율적 자료 관리 및 메모리 관리<br><br>
            주사용 분야 : <br>
            * 시스템 프로그램 운영체제 ,디버깅 S/W, 미들웨어 ) : 비트 조작 , 메모리 접근 , 형 변환<br>
            * 컴파일러, 유틸리티<br>
            * 응용 프로그램(게임, 워드프로세서, 오라클)<br>
        </div><br>
        <h4>C++</h4>
        <p data-ke-size="size18">
            1. 객체지향 언어로 C언어의 확장판 <br>
            2. 다중 상속, 오버로드<br>
            3. 컴파일러 언어 <br>

        </p>
        <div class="well">
            특징 :<BR>
            * 하드웨어 제어 + 객체지향 프로그래밍<br>
            * C언어 라이브러리를 상당수 사용 가능<br>
            * 효율적 자료 관리 및 메모리 관리<br><br>
            주사용 분야 : <br>
            * 게임 프로그램<br>
            * 빠른 처리가 필요한 응용프로그램<br>
            * 하드웨어 제어 프로그램<br>
        </div><br>
        <h4>C#</h4>
        <p data-ke-size="size18">
            1. 객체지향 언어(C언어의 기본문법 + C++의 객체 지향개념 + UI컴포넌트) <br>
            2. .NET프레임워크에서 개발<br>
            3. 이 기종간에 인터넷을 통한 자료 교환을 위해 개발<br>

        </p>
        <div class="well">
            특징 :<BR>
            * .NET프레임워크에서 동작하므로 운영체제에 독립적<br>
            * CRL(Common Runtime Library)를 지원<br>
            * 뛰어난 생산성<br><br>
            주사용 분야 : <br>
            * 웹 응용프로그램<br>
            * 네트워크 프로그램<br>
        </div><br>
        <h4>JAVA</h4>
        <p data-ke-size="size18">
            1. C++과 유사한나 모호하거나 복잡한 기능을 제거한 객체지향 프로그램 <br>
            2. 모든 데이터는 객체를 통하여 처리<br>
            3. 바이트 코드로 컴파일되기 때문에 자바를 지원하는 어떠한 플랫폼에서도 실행<br>

        </p>
        <div class="well">
            특징 :<BR>
            * 가상머신에서 동작하므로 운영체제에 독립적<br>
            * 다중 쓰레드 프로그램이 가능<br>
            * 뛰어난 호환성<br><br>
            주사용 분야 : <br>
            * 웹 응용프로그램<br>
            * 분산환경에 적합한 언어<br>
            * 휴대기기용 프로그램<br>
        </div><br>
        <h4>Pathon</h4>
        <p data-ke-size="size18">
            1. 인간 친화적 언어로 익히기 쉬운 언어<br>
            2. 다른 언어와 혼합하여 개발 가능<br>

        </p>
        <div class="well">
            특징 :<BR>
            * 개발 속도가 빠르고 간결<br>
            * 무료 소프트웨어<br>
            <br>
            주사용 분야 : <br>
            * C/C++과의 결합<br>
            * 웹 프로그래밍<br>
            * GUI 프로그래밍<br>
        </div><br>

        <pre class="line-numbers"><code class="language-js">
    #include <stdio.h>
    #define ST_NUM 20
    #define NAME_LENGTH 10

    typedef struct sungjuk {
            char name[NAME_LENGTH];
            int kor , eng ,mat;
            double avg;
    }SUNGJUK;

    int inScore (SUNGJUK* , int);
    void outScore (SUNGJUK* , int);
    void sortScore (SUNGJUK* , int);
</code></pre><br>
    <h3>main함수</h3>
    <pre class="line-numbers"><code class="language-js">
iut main()
{
        int sel, totalScnt=0;
        SUNGJUK student[ST_NUM];
        while(1){
                    put("|n원하는 메뉴를 선택하세요");
                    put("1. 성적입력");
                    put("2. 성적순출력");
                    put("0. 종료");
                    scanf("%d", &sel);
                    fflush(stdin);
                    switch(sel);
        }
}
</code></pre><br>
    <h3>입출력함수</h3>
    <pre class="line-numbers"><code class="language-js">
#include "scoreHeader.h"
int inScore(SUNGJUK * st, int cnt)
{
        char op;
        do{
                    fflush(stdin);
                    printf("\n이름:");
                    gets(st[cnt].name;
                    printf("국어:");
                    scanf("%d", &st[cnt].kor);
                    printf("영어:");
                    scanf("%d", &st[cnt].eng);
                    printf("수학":");
                    scanf("%d", &st[cnt].mat);
        }
}
</code></pre><br>

    <h3>코드분석</h3><br>
    <p data-ke-size="size18">

        <ul>
            <li>매크로 상수는 프로그램의 가독성을 높이고 유지보수를 편리하게 하는 장점이 있음</li>
            <li>사용자 정의 헤더파일은 ""를 이용하여 기술함.</li>
        </ul>

</body>

</html>

<div class="well">
    * 형식매개변수(Formal Parameter) : 함수 정의에서 기술되는 매개변수 목록<br>
    * 실매개변수(Real Parameter) : 함수 호출에서 기술되는 값, 인자(Argument)<br>
</div><br>
<p data-ke-size="size18">
    구조체가 가진 멤버를 비트 단위로 사용<br>
    비트 필드의 정의 : 멤버이름 + : + 비트 수 기술 <br>
    메모리에 할당할 때, 첫 번째 멤버를 최하위 비트에서부터 할당<br>
    비트필드의 멤버에 표현 가능한 범위 밖의 값을 저장하면 오버플로우가 발생<br>
    비트필드를 정희할 때는 중간에 일부 비트를 비워두고 멤버를 특정 비트에 할당할 수 있음 <br></p>


</p>
<p data-ke-size="size16">포인터 오류</p>
<p data-ke-size="size18"></p>
<ul>
    <li> 포인터도 변수이므로 반드시 초기화 해야 함</li>
    <li> 포인터 변수를 초기화하지 않고 사용하면 실행 에러가 발생함</li>
    <li> 널포인터: 포인터가 다른 변수를 가리키지 않을 때는 NULL(0)로 초기화함</li>
    <li> 포인터를 안전하게 사용하려면 우선 포인터가 널 포인터인지를 검사</li>
    <li> 포인터 변수의 데이터형이 반드시 포인터 변수가 가리키는 변수의 데이터형과 일치해야함</li>
</ul><br>


</ul>
<p data-ke-size="size16">배열의 시작 주소로 초기화된 포인터를 이용해서 배열의 모든 원소에 접근 가능 <br>
    포인터 변수를 배열 이름인 것처럼 사용 가능<br>
    포인터와 +,- 연산<br></p>
<div class="well">
    * p + N : p가 가리키는 데이터형 N개 크기만큼 증가된 주소가 연산의 결과<br>
    * p - N : p가 가리키는 데이터형 N개 크기만큼 감소된 주소가 연산의 결과<br>
</div>
</p>


<h4>[2]포인터와 배열 원소</h4>
<p>
    배열의 원소를 가리키는 포인터는 배열의 어떤 원소든지 가리킬 수 있음
    포인터가 배열의 원소가 아닌 일반 변수를 가리킬 때도 *(p+i) == p[1]는 항상 성립함
    <div class="well">
        * 배열과 포인터의 차이점 *<br>
        * 배열이 메모리에 할당되고 나면 , 배열의 시작 주소 변경 불가<br>
        * 포인터 변수는 값을 변경할 수 있으므로 , 포인터 변수에 보관된
        주소는 변경 가능<br>
    </div>
</p>


<ul>
    <li>포인터 배열은 주소를 보관하는 배열임</li>
    <li>포인터 배열을 이용하여 각 변수를 참조하는 것이 가능함</li>
    <li>여러 개의 문자열을 하나로 묶어 처리하는 방법으로 문자 포인터 배열을 이용할 수 있음</li>
</ul>




<p>
    <h3>포인터 이용</h3>
    <h4>[1]포인터 증감 연산</h4>

    포인터와++, 연산 : 포인터에대한 증감 연산 (++,--) 도 포인터형에 의해 연산의 결과가 결정 <br>
    int arr [5];<br>
    int * p = arr [0];<br>
    for(i = 0 ; i <5 ; i ++, p++)<br>
        printf (“&d ＼ n”, *p );
        <br>
        <h4>[2]포인터 배열 처리</h4>

        포인터 배열 : 주소를 저장하는 배열 <br>
        형식 : 데이터 타입 * 포인터 변수명[크기];<br>
        <div class="well">
            * 배열명을 포인터 변수와 같이 연산에 의해 배열요소를 참조할 수있음<br>
            * 포인터 변수에 증감 연산자를 이용하여 배열요소를 참조할 수 있음<br>
            * 후위 증감 연산자가 , 전위 증감 연산자보다 우선순위가 높음<br>
        </div>
</p>


2.gets()<br>
<div class="well">
    * 공백을 포함한 문자열 입력<br>
    * char* gets(char * str);<br>
    * enter를 0’ 으로 변환하여 저장<br>
</div>
<h3>2) 문자열 표준 출력</h3>

1.printf()<br>
<div class="well">
    * 형식문자열 "%s"를 이용<br>
    * 문자 배열명을 printf함수의 첫번째 인자로 인식<br>
    * 함수 형식 : int scanf (“%s", str);<br>
</div>
1.pust()<br>
<div class="well">
    * int puts(const char* str);<br>
    * str 배열의 문자열을 표준 출력에 출력<br>
    * 배열의 "\0"을 '\n'로 변환하여 출력<br>
</div>







초기화 : " "문자를 대입연산자에 이용<br>
<ul>
    <li>값이 변경되지 않는 문자열 A나 “Hello World” 등 - 문자열 리터럴이라고도 함</li>
</ul>
문자열 변수
<ul>
    <li>•
        프로그램 수행 중에 변경될 수 있는 문자열 - 문자 배열</li>
    <li>배열의 크기는 상수로만 지정한다.</li>
</ul>
배열의 사용<br>
<ul>
    <li>배열의 각 원소에 접근하려면 인덱스를 사용함</li>
    <li>인덱스는 항상 0~(배열의 크기-1)사이의 값임</li>
</ul>
배열의 초기화
<ul>
    <li>배열을 초기화하려면 {}안에 초기값을 나열함</li>
    <li>배열선언시 초기화할때는 배열의 크기를 생략할 수 있음</li>
    <li>필요시 2차원 이상의 배열 형태를 구현하는 것이 가능함</li>
    <li>실제 메모리 구조는 인접한 메모리의 연속임</li>
</ul>
</p><br>
<h4>[2] 다차원 배열</h4>

2차원 배열 : <br>
<ul>
    <li>필요시 2차원 이상의 배열 형태를 구현하는 것이 가능함</li>
    <li>실제 메모리 구조는 인접한 메모리의 연속임</li>
</ul>



<p data-ke-size="size16">
    함수 시작 시 생성되고 종료 시 소멸<br></p>
<p data-ke-size="size16">
    생성 시 쓰레기값을 가짐<br>
    매개변수도 지역변수임<br>
    선언된 블록에서 유효</p>
<br>
<h3>전역변수</h3>
<div class="well">
    * 프로그램 내 전체 함수에서 유효, Global Variable<br>
    * 프로그램 시작 시 생성, 데이터 영역에 생성<br>
    * 프로그램 종료 시 소멸<br>
    * 함수 밖에서 선언<br>
    * 자동으로 0으로 초기화 <br>
    * 전역변수는 프로그램 전체에서 참조하므로 복잡성을 증대<br>
    * 모듈화의 독립성 확보가 어려움<br>
    * 메모리 공간을 점유<br>
</div>
<h4>다중파일</h4>
<p data-ke-size="size16">
    extern을 선언하여 외부에서도 참조 가능<br>
    extern int 변수; 외부에 선언된 변수를 참조한다는 선언문</p>


</p>
<h4>[1]함수 선언 및 호출</h4>
<div class="well">
    * 함수는 사용 전 반드시 선언해야 함<br>
    * 선언은 함수의 원형(Prototype)을 기술함<br>
    * 선언 시 매개변수 이름은 생략 가능함<br>
    * 함수 호출 전에 정의문이 먼저 기술된 경우는 생략 가능함<br>
</div>

<p>
    <p data-ke-size="size16"></p>
    int sub( int a, int b);<br>
    int sub( int, int);<br>

    <h4>호출</h4>
    sub (3, 7); -> int sub(int a, int b) { ... }<br>
    * "," 로 구분하여 여러 개 전달 가능<br>
    * 매개변수가 없는 경우에는 void<br>
</p>
</body>

</html>
<ul>
    <li>문자열은 큰 따옴표 (“ 로 표현함</li>
    <li>문자열의 끝에는 널 문자 ＼ 0 를 함께 저장함</li>
</ul>
<h3>용어</h3>
<div class="well">
    * 요소(elements) : 배열을 구성하는 각 항목<br>
    * 배열(Array)명 : 전체 공간에 대한 대표 이름(변수명)<br>
    * 크기 : 배열요소의 개수<br>
    * 첨자(Index) : 각 요소에 부여되는 위치 정보<br>
</div>
</p>

div class="well">
형식<br>
* 기억부류 데이터형 변수명;<br>
* 기억부류 리턴형 함수명(매개변수 리스트);<br></div>

<h4>auto 변수</h4><br>
<p data-ke-size="size18">
    지역 변수는 디폴트로 auto 기억 부류를 사용<br>
    -> auto 지역 변수는 선언된 위치에서 자동으로 생성되고, 선언된 블록을 빠져나갈 때 자동으로 해제됨<br>
    전역 변수에는 auto 지정 불가능<br>
    for 루프에서 선언 시 루프 내에서만 통용<br></p>
<h4>register 변수</h4><br>
<ul>
    <li>변수를 메모리에 할당하는 대신 CPU의 레지스터에 할당</li>
    <li>변수를 레지스터에 할당하면 변수에 좀 더 빠르게 접근</li>
    <li>보통 루프 제어 변수를 레지스터 변수로 선언</li>
    <li>register 변수로 선언해도 변수가 레지스터에 할당되지 않을 수 있음</li>
    <li>레지스터 변수에 대해서는 주소 구하기 연산자를 사용할 수 없음</li>
</ul><br>
<h4>global 변수</h4><br>
<p data-ke-size="size18">
    다른 곳에 선언된 변수에 대하여 별도의 메모리 할당 없이 해당 변수를 사용<br>
    전역 변수를 코드 중간에 선언하면, 전역 변수가 선언된 뒤쪽에 정의된 함수에서만 전역 변수를 사용 가능<br>
    전방 선언(Forward Declaration) : <br>
    전역 변수에 대한 extern 선언이 있으면 전역 변수가 선언된 위치와 관계없이 전역 변수 사용 가능<br></p>

<h3>정적 변수</h3><br>
<h4>정적 지역 변수 : static</h4>
<ul>
    <li>번역 과정의 마지막 단꼐인 적재 시간에 기억 장소를 할당받는 변수</li>
    <li>전체 프로그램의 시작부터 종료까지를 생존 기간으로 하여 동일 기억 장소를 유지 </li>
    <li>초기화는 기억 공간 할당 시 한 번만 초기화됨</li>
    <li>정적 지역 변수는 전역 변수처럼 프로그램이 시작할 때 메모리에 할당되고 프로그램이 종료할 때 해체</li>
    <li>전역 변수와는 달리 정적 지역 변수는 선언된 함수 안에서만 사용</li>
    <li>정적 지역 변수는 함수가 리턴하더라도 해제되지 않고 남아있다가 그 다음 함수 호출 시 그대로 다시 이용</li>
</ul><br>
<h4>정적 전역 변수</h4><br>
<p data-ke-size="size18">
    정적 전역 변수는 정적 전역 변수가 선언된 소스 파일에서만 사용<br>
    정적 전역 변수는 전역 변수를 다른 소스 파일에서 접근하지 못하도록 제한<br><br>

    <table>
        <div>
            <tr>
                <th>구분</th>
                <th>일반 지역 변수</th>
                <th>정적 지역 변수</th>
                <th>전역 변수</th>
                <th>정적 전역 변수</th>
            </tr>
            <tr>
                <td>선언 위치</td>
                <td>함수 안</td>
                <td>함수 안</td>
                <td>함수 밖</td>
                <td>함수 밖</td>
            </tr>
            <tr>
                <td>생성 시점</td>
                <td>변수 선언 시</td>
                <td>프로그램 시작 시</td>
                <td>프로그램 시작 시</td>
                <td>프로그램 시작 시</td>
            </tr>
            <tr>
                <td>해제 시점</td>
                <td>함수 리턴 시</td>
                <td>프로그램 종료 시</td>
                <td>프로그램 종료 시</td>
                <td>프로그램 종료 시</td>
            </tr>
            <tr>
                <td>사용 범위</td>
                <td>함수 안</td>
                <td>함수 안</td>
                <td>프로그램 전체</td>
                <td>선언된 소스 파일</td>
            </tr>
            <tr>
                <td>초기화 하지 않았을 때</td>
                <td>쓰레기 값</td>
                <td>0으로 초기화</td>
                <td>0으로 초기화</td>
                <td>0으로 초기화</td>
            </tr>

        </div>
    </table><br>