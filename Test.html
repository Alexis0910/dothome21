<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>프로그래밍 언어별 특성</title>
    <style>
        .table {
            border: 1px solid #000;
            border-collapse: collapse;
        }

        .table tr th {
            margin: 5px;
            border: 1px solid #000;

        }

        .table tr td {
            border: 1px solid #000;
        }
    </style>
</head>

<body>
    <h2>문자처리 라이브러리</h2><br>

    <h3>문자 문자열 입출력</h3>
    <p data-ke-size="size18">
        [1] 라이브러리<br>
        • scanf (“%c",&ch), printf(“%c”, ch);<br>
        • getc(); putc<br>
        • _getch(); getche(); putch();<br>
        • getchar(); putchar();<br>
        <h4>getc() putc()</h4>
        <div class="well">
            int getc (FILE *stream );<br>
            * 지정한 스트림으로 부터 문자 읽기<br>
            * 입력문자 ASCII 코드 값을 리턴 , 오류 시는 EOF 리턴<br><br>
            int putc (int ch, FILE *stream );<br>
            * 지정한 스트림에 지정한 값을 출력<br>
            * 정상 출력시 출력문자 리턴, 오류 시는 EOF리턴<BR>
            </div>
    <h4>_getch() _getche() _putch()</h4>
    int_getch(void); int_getche (void); : 키보드로부터 입력되는 문자를 읽음, 입력 문자의 ASCII 코드를 리턴,버퍼를 사용하지 않는 입력<br>
    int_putch (int ch); : 화면에 지정한 값을 출력,정상 출력 시 출력문자 리턴 , 오류 시 EOF 리턴<br>
    </p>

    
    <h4>표준 라이브러리</h4>
    <ul>
        <li>작업에 필요한 라이브러리 함수 검색</li>
        <li>헤더파일과 함수 원형 파악</li>
        <li>include 와 매개변수 기술</li>
    </ul>

    <h4>C표준 라이브러리</h4>
<h5>*구조체는 포인터로 전달*</h5>
    <pre class="line-numbers"><code class="language-js">
/*
sqrt example */
#include < stdio.h > /* printf
#include < math.h > /* sqrt

int main ()
{
    double param , result;
    param = 1024.0;
    result = sqrt (param); 
    printf("sqrt (%f) = %fn”, param ,
result );
    return 0;
}
</code></pre><br>
<h4>Visual Studio에서 만들기</h4>
<ul>
    <li>정적 라이브러리 프로젝트로 생성</li>
    <li>헤더파일과 소스코드를 작성</li>
    <li>lib 빌드</li>
</ul>
<h4>DEV C++에서 만들기</h4>
<ul>
    <li>정적 라이브러리 프로젝트로 생성</li>
    <li>헤더파일과 소스코드를 작성</li>
    <li>오브젝트 파일 생성</li>
    <li>.a 파일 생성</li>
</ul>


<h5>*바이트(Byte) 이상의 데이터는 포인터로 전달*</h5>
    <pre class="line-numbers"><code class="language-js">
void sub( double m1, double m2 )
{
    ……
}
int main()
{
    double im, si ;
    ……
    ……
    sub( im, si );
    ……
}
</code></pre><br>
<h5>*여러 개의 매개변수를 구조체로 전달*</h5>
    <pre class="line-numbers"><code class="language-js">
struct test {
    int a,b;
    double c;
};
void sub( double o, double p, double q, double r, double s )
{
    ……
}
int main()
{
    double a,b,c,d,e;
    struct test im;
    ……
    ……
    sub( a,b,c,d,e);
    ……
}
</code></pre><br>

<h5>*연산의 최적화 - 실수 연산을 최소화(정수의 연산으로)*</h5>
    <pre class="line-numbers"><code class="language-js">
int main()
{
    double a=5.0, b=3.0, c;
    double d=15.34, e=3.0, f;
    c = a * b;
    f = d * e;
}
int main()
{
    int p,q,r;
    double a=5.0, b=3.0, c;
    double d=15.34, e=3.0, f;
    p = a;
    q= b;
    r = p * q;

    p = d * 100; // 소수점 이하 2자리의 배정도
    q = e * 100;
    f = ( p * q )/100;
}
</code></pre><br>
<h5>*안정성 확보를 통한 최적화 - const활용*</h5>
    <pre class="line-numbers"><code class="language-js">
void sub( const double m1, double m2 )
{
    m2 = 4.7
}
int main()
{
    double im, si ;
    ……
    ……
    sub( im, si );
    ……
}
</code></pre><br>

<h3>디버거(Debugger)/h3>
<p data-ke-size="size18">
    디버깅을 수행하는 프로그램 : Visual Studio, Code Blocks<br>
    대부분의 IDE는 디버거를 내장<br>
</p>
    <ul>
        <li>변수값 추적</li>
        <li>중단점 지정</li>
        <li>모듈 단위 실행</li>
        
    </ul><br>
    <h4>Visual Studio Debugging</h4>
    <p data-ke-size="size18">
        디버깅 순서<BR>
        1. 프로그램 오류가 발생한 곳이라고 의심되는 부분에 중단점을 설정하기<br>
        2. ‘디버깅 시작’ 누르기<br>
        3. 프로그램이 실행되다가 중단점을 만나면 그 부분에서 멈추기<br>
        4. ‘F11’키로 한 줄씩 실행하면서 아래 ‘자동’창의 변수값 확인 및 오류 찾기<br>
        5. ‘Shift + F5’로 디버깅을 종료하고 오류 수정하기<br>
    </p>
    <h4>DEV C++ Debugging</h4>
        <div class="well">
            디버깅 순서<BR>
            * 프로그램 오류가 발생한 곳이라고 의심되는 부분에 중단점을 설정하기<br>
            * [debug] 탭에서 ‘debug’를 클릭하기<br>
            * 프로그램이 실행되다가 중단점을 만나면 그 부분에서 멈추기<br>
            * ‘F7’키로 한 줄씩 실행하면서 변수값 확인 및 프로그램 실행 화면에서 오류 찾기<br>
            * [Stop Execution] 버튼을 눌러 디버깅 종류 및 오류 수정<br>
        </div><br>
        <h4>Code Blocks Debugging</h4>

            <div class="well">
                * 프로그램 오류가 발생한 곳이라고 의심되는 부분에 중단점을 설정하기<br>
                * [debug]탭에서 [start], [step into] 클릭하기<br>
                * 로그램이 실행되다가 중단점을 만나면 그 부분에서 멈추기<br>
                * ‘F7’키로 한 줄씩 실행하면서 프로그램이 실행된 화면에서 오류 찾기<br>
                * 변수 추적은 [debug]의 [debugging windows]-[watches]를 열어서 확인<br>
                * [stop debugging] 버튼을 눌러서 디버깅을 종료하고 오류를 수정<br>
            </div><br>

            <h3>컴퓨터 언어 종류</h3>
            <h4>C</h4>
            <p data-ke-size="size18">
                1. 어셈블리어와 고급 언어의 장점을 가지고 있음 <br>
                2. 작고 빠른 프로그램<br>
                3. 뛰어난 이식성<br>
                4. 컴파일러 언어<br>
            </p>
                <div class="well">
                    특징 :<BR>
                    * 하드웨어 제어<br>
                    * 범용 프로그래밍<br>
                    * 효율적 자료 관리 및 메모리 관리<br><br>
                    주사용 분야 : <br>
                    * 시스템 프로그램 운영체제 ,디버깅 S/W, 미들웨어 ) : 비트 조작 , 메모리 접근 , 형 변환<br>
                    * 컴파일러, 유틸리티<br>
                    * 응용 프로그램(게임, 워드프로세서, 오라클)<br>
                </div><br>
            <h4>C++</h4>
            <p data-ke-size="size18">
                1. 객체지향 언어로 C언어의 확장판 <br>
                2. 다중 상속, 오버로드<br>
                3. 컴파일러 언어 <br>

            </p>
                <div class="well">
                    특징 :<BR>
                    * 하드웨어 제어 + 객체지향 프로그래밍<br>
                    * C언어 라이브러리를 상당수 사용 가능<br>
                    * 효율적 자료 관리 및 메모리 관리<br><br>
                    주사용 분야 : <br>
                    * 게임 프로그램<br>
                    * 빠른 처리가 필요한 응용프로그램<br>
                    * 하드웨어 제어 프로그램<br>
                </div><br>
            <h4>C#</h4>
            <p data-ke-size="size18">
                1. 객체지향 언어(C언어의 기본문법 + C++의 객체 지향개념 + UI컴포넌트) <br>
                2. .NET프레임워크에서 개발<br>
                3. 이 기종간에 인터넷을 통한 자료 교환을 위해 개발<br>

            </p>
                <div class="well">
                    특징 :<BR>
                    * .NET프레임워크에서 동작하므로 운영체제에 독립적<br>
                    * CRL(Common Runtime Library)를 지원<br>
                    * 뛰어난 생산성<br><br>
                    주사용 분야 : <br>
                    * 웹 응용프로그램<br>
                    * 네트워크 프로그램<br>
                </div><br>
            <h4>JAVA</h4>
            <p data-ke-size="size18">
                1. C++과 유사한나 모호하거나 복잡한 기능을 제거한 객체지향 프로그램 <br>
                2. 모든 데이터는 객체를 통하여 처리<br>
                3. 바이트 코드로 컴파일되기 때문에 자바를 지원하는 어떠한 플랫폼에서도 실행<br>

            </p>
                <div class="well">
                    특징 :<BR>
                    * 가상머신에서 동작하므로 운영체제에 독립적<br>
                    * 다중 쓰레드 프로그램이 가능<br>
                    * 뛰어난 호환성<br><br>
                    주사용 분야 : <br>
                    * 웹 응용프로그램<br>
                    * 분산환경에 적합한 언어<br>
                    * 휴대기기용 프로그램<br>
                </div><br>
                <h4>Pathon</h4>
                <p data-ke-size="size18">
                    1. 인간 친화적 언어로 익히기 쉬운 언어<br>
                    2. 다른 언어와 혼합하여 개발 가능<br>

                </p>
                    <div class="well">
                        특징 :<BR>
                        * 개발 속도가 빠르고 간결<br>
                        * 무료 소프트웨어<br>
<br>
                        주사용 분야 : <br>
                        * C/C++과의 결합<br>
                        * 웹 프로그래밍<br>
                        * GUI 프로그래밍<br>
                    </div><br>

    <pre class="line-numbers"><code class="language-js">
    #include <stdio.h>
    #define ST_NUM 20
    #define NAME_LENGTH 10

    typedef struct sungjuk {
            char name[NAME_LENGTH];
            int kor , eng ,mat;
            double avg;
    }SUNGJUK;

    int inScore (SUNGJUK* , int);
    void outScore (SUNGJUK* , int);
    void sortScore (SUNGJUK* , int);
</code></pre><br>
    <h3>main함수</h3>
    <pre class="line-numbers"><code class="language-js">
iut main()
{
        int sel, totalScnt=0;
        SUNGJUK student[ST_NUM];
        while(1){
                    put("|n원하는 메뉴를 선택하세요");
                    put("1. 성적입력");
                    put("2. 성적순출력");
                    put("0. 종료");
                    scanf("%d", &sel);
                    fflush(stdin);
                    switch(sel);
        }
}
</code></pre><br>
    <h3>입출력함수</h3>
    <pre class="line-numbers"><code class="language-js">
#include "scoreHeader.h"
int inScore(SUNGJUK * st, int cnt)
{
        char op;
        do{
                    fflush(stdin);
                    printf("\n이름:");
                    gets(st[cnt].name;
                    printf("국어:");
                    scanf("%d", &st[cnt].kor);
                    printf("영어:");
                    scanf("%d", &st[cnt].eng);
                    printf("수학":");
                    scanf("%d", &st[cnt].mat);
        }
}
</code></pre><br>

    <h3>코드분석</h3><br>
    <p data-ke-size="size18">

        <ul>
            <li>매크로 상수는 프로그램의 가독성을 높이고 유지보수를 편리하게 하는 장점이 있음</li>
            <li>사용자 정의 헤더파일은 ""를 이용하여 기술함.</li>
        </ul>

</body>

</html>

<div class="well">
    * 형식매개변수(Formal Parameter) : 함수 정의에서 기술되는 매개변수 목록<br>
    * 실매개변수(Real Parameter) : 함수 호출에서 기술되는 값, 인자(Argument)<br>
</div><br>
<p data-ke-size="size18">
    구조체가 가진 멤버를 비트 단위로 사용<br>
    비트 필드의 정의 : 멤버이름 + : + 비트 수 기술 <br>
    메모리에 할당할 때, 첫 번째 멤버를 최하위 비트에서부터 할당<br>
    비트필드의 멤버에 표현 가능한 범위 밖의 값을 저장하면 오버플로우가 발생<br>
    비트필드를 정희할 때는 중간에 일부 비트를 비워두고 멤버를 특정 비트에 할당할 수 있음 <br></p>


</p>
<p data-ke-size="size16">포인터 오류</p>
<p data-ke-size="size18"></p>
<ul>
    <li> 포인터도 변수이므로 반드시 초기화 해야 함</li>
    <li> 포인터 변수를 초기화하지 않고 사용하면 실행 에러가 발생함</li>
    <li> 널포인터: 포인터가 다른 변수를 가리키지 않을 때는 NULL(0)로 초기화함</li>
    <li> 포인터를 안전하게 사용하려면 우선 포인터가 널 포인터인지를 검사</li>
    <li> 포인터 변수의 데이터형이 반드시 포인터 변수가 가리키는 변수의 데이터형과 일치해야함</li>
</ul><br>


</ul>
<p data-ke-size="size16">배열의 시작 주소로 초기화된 포인터를 이용해서 배열의 모든 원소에 접근 가능 <br>
    포인터 변수를 배열 이름인 것처럼 사용 가능<br>
    포인터와 +,- 연산<br></p>
<div class="well">
    * p + N : p가 가리키는 데이터형 N개 크기만큼 증가된 주소가 연산의 결과<br>
    * p - N : p가 가리키는 데이터형 N개 크기만큼 감소된 주소가 연산의 결과<br>
</div>
</p>


<h4>[2]포인터와 배열 원소</h4>
<p>
    배열의 원소를 가리키는 포인터는 배열의 어떤 원소든지 가리킬 수 있음
    포인터가 배열의 원소가 아닌 일반 변수를 가리킬 때도 *(p+i) == p[1]는 항상 성립함
    <div class="well">
        * 배열과 포인터의 차이점 *<br>
        * 배열이 메모리에 할당되고 나면 , 배열의 시작 주소 변경 불가<br>
        * 포인터 변수는 값을 변경할 수 있으므로 , 포인터 변수에 보관된
        주소는 변경 가능<br>
    </div>
</p>


<ul>
    <li>포인터 배열은 주소를 보관하는 배열임</li>
    <li>포인터 배열을 이용하여 각 변수를 참조하는 것이 가능함</li>
    <li>여러 개의 문자열을 하나로 묶어 처리하는 방법으로 문자 포인터 배열을 이용할 수 있음</li>
</ul>




<p>
    <h3>포인터 이용</h3>
    <h4>[1]포인터 증감 연산</h4>

    포인터와++, 연산 : 포인터에대한 증감 연산 (++,--) 도 포인터형에 의해 연산의 결과가 결정 <br>
    int arr [5];<br>
    int * p = arr [0];<br>
    for(i = 0 ; i <5 ; i ++, p++)<br>
        printf (“&d ＼ n”, *p );
        <br>
        <h4>[2]포인터 배열 처리</h4>

        포인터 배열 : 주소를 저장하는 배열 <br>
        형식 : 데이터 타입 * 포인터 변수명[크기];<br>
        <div class="well">
            * 배열명을 포인터 변수와 같이 연산에 의해 배열요소를 참조할 수있음<br>
            * 포인터 변수에 증감 연산자를 이용하여 배열요소를 참조할 수 있음<br>
            * 후위 증감 연산자가 , 전위 증감 연산자보다 우선순위가 높음<br>
        </div>
</p>


2.gets()<br>
<div class="well">
    * 공백을 포함한 문자열 입력<br>
    * char* gets(char * str);<br>
    * enter를 0’ 으로 변환하여 저장<br>
</div>
<h3>2) 문자열 표준 출력</h3>

1.printf()<br>
<div class="well">
    * 형식문자열 "%s"를 이용<br>
    * 문자 배열명을 printf함수의 첫번째 인자로 인식<br>
    * 함수 형식 : int scanf (“%s", str);<br>
</div>
1.pust()<br>
<div class="well">
    * int puts(const char* str);<br>
    * str 배열의 문자열을 표준 출력에 출력<br>
    * 배열의 "\0"을 '\n'로 변환하여 출력<br>
</div>







초기화 : " "문자를 대입연산자에 이용<br>
<ul>
    <li>값이 변경되지 않는 문자열 A나 “Hello World” 등 - 문자열 리터럴이라고도 함</li>
</ul>
문자열 변수
<ul>
    <li>•
        프로그램 수행 중에 변경될 수 있는 문자열 - 문자 배열</li>
    <li>배열의 크기는 상수로만 지정한다.</li>
</ul>
배열의 사용<br>
<ul>
    <li>배열의 각 원소에 접근하려면 인덱스를 사용함</li>
    <li>인덱스는 항상 0~(배열의 크기-1)사이의 값임</li>
</ul>
배열의 초기화
<ul>
    <li>배열을 초기화하려면 {}안에 초기값을 나열함</li>
    <li>배열선언시 초기화할때는 배열의 크기를 생략할 수 있음</li>
    <li>필요시 2차원 이상의 배열 형태를 구현하는 것이 가능함</li>
    <li>실제 메모리 구조는 인접한 메모리의 연속임</li>
</ul>
</p><br>
<h4>[2] 다차원 배열</h4>

2차원 배열 : <br>
<ul>
    <li>필요시 2차원 이상의 배열 형태를 구현하는 것이 가능함</li>
    <li>실제 메모리 구조는 인접한 메모리의 연속임</li>
</ul>



<p data-ke-size="size16">
    함수 시작 시 생성되고 종료 시 소멸<br></p>
<p data-ke-size="size16">
    생성 시 쓰레기값을 가짐<br>
    매개변수도 지역변수임<br>
    선언된 블록에서 유효</p>
<br>
<h3>전역변수</h3>
<div class="well">
    * 프로그램 내 전체 함수에서 유효, Global Variable<br>
    * 프로그램 시작 시 생성, 데이터 영역에 생성<br>
    * 프로그램 종료 시 소멸<br>
    * 함수 밖에서 선언<br>
    * 자동으로 0으로 초기화 <br>
    * 전역변수는 프로그램 전체에서 참조하므로 복잡성을 증대<br>
    * 모듈화의 독립성 확보가 어려움<br>
    * 메모리 공간을 점유<br>
</div>
<h4>다중파일</h4>
<p data-ke-size="size16">
    extern을 선언하여 외부에서도 참조 가능<br>
    extern int 변수; 외부에 선언된 변수를 참조한다는 선언문</p>


</p>
<h4>[1]함수 선언 및 호출</h4>
<div class="well">
    * 함수는 사용 전 반드시 선언해야 함<br>
    * 선언은 함수의 원형(Prototype)을 기술함<br>
    * 선언 시 매개변수 이름은 생략 가능함<br>
    * 함수 호출 전에 정의문이 먼저 기술된 경우는 생략 가능함<br>
</div>

<p>
    <p data-ke-size="size16"></p>
    int sub( int a, int b);<br>
    int sub( int, int);<br>

    <h4>호출</h4>
    sub (3, 7); -> int sub(int a, int b) { ... }<br>
    * "," 로 구분하여 여러 개 전달 가능<br>
    * 매개변수가 없는 경우에는 void<br>
</p>
</body>

</html>
<ul>
    <li>문자열은 큰 따옴표 (“ 로 표현함</li>
    <li>문자열의 끝에는 널 문자 ＼ 0 를 함께 저장함</li>
</ul>
<h3>용어</h3>
<div class="well">
    * 요소(elements) : 배열을 구성하는 각 항목<br>
    * 배열(Array)명 : 전체 공간에 대한 대표 이름(변수명)<br>
    * 크기 : 배열요소의 개수<br>
    * 첨자(Index) : 각 요소에 부여되는 위치 정보<br>
</div>
</p>

div class="well">
형식<br>
* 기억부류 데이터형 변수명;<br>
* 기억부류 리턴형 함수명(매개변수 리스트);<br></div>

<h4>auto 변수</h4><br>
<p data-ke-size="size18">
    지역 변수는 디폴트로 auto 기억 부류를 사용<br>
    -> auto 지역 변수는 선언된 위치에서 자동으로 생성되고, 선언된 블록을 빠져나갈 때 자동으로 해제됨<br>
    전역 변수에는 auto 지정 불가능<br>
    for 루프에서 선언 시 루프 내에서만 통용<br></p>
<h4>register 변수</h4><br>
<ul>
    <li>변수를 메모리에 할당하는 대신 CPU의 레지스터에 할당</li>
    <li>변수를 레지스터에 할당하면 변수에 좀 더 빠르게 접근</li>
    <li>보통 루프 제어 변수를 레지스터 변수로 선언</li>
    <li>register 변수로 선언해도 변수가 레지스터에 할당되지 않을 수 있음</li>
    <li>레지스터 변수에 대해서는 주소 구하기 연산자를 사용할 수 없음</li>
</ul><br>
<h4>global 변수</h4><br>
<p data-ke-size="size18">
    다른 곳에 선언된 변수에 대하여 별도의 메모리 할당 없이 해당 변수를 사용<br>
    전역 변수를 코드 중간에 선언하면, 전역 변수가 선언된 뒤쪽에 정의된 함수에서만 전역 변수를 사용 가능<br>
    전방 선언(Forward Declaration) : <br>
    전역 변수에 대한 extern 선언이 있으면 전역 변수가 선언된 위치와 관계없이 전역 변수 사용 가능<br></p>

<h3>정적 변수</h3><br>
<h4>정적 지역 변수 : static</h4>
<ul>
    <li>번역 과정의 마지막 단꼐인 적재 시간에 기억 장소를 할당받는 변수</li>
    <li>전체 프로그램의 시작부터 종료까지를 생존 기간으로 하여 동일 기억 장소를 유지 </li>
    <li>초기화는 기억 공간 할당 시 한 번만 초기화됨</li>
    <li>정적 지역 변수는 전역 변수처럼 프로그램이 시작할 때 메모리에 할당되고 프로그램이 종료할 때 해체</li>
    <li>전역 변수와는 달리 정적 지역 변수는 선언된 함수 안에서만 사용</li>
    <li>정적 지역 변수는 함수가 리턴하더라도 해제되지 않고 남아있다가 그 다음 함수 호출 시 그대로 다시 이용</li>
</ul><br>
<h4>정적 전역 변수</h4><br>
<p data-ke-size="size18">
    정적 전역 변수는 정적 전역 변수가 선언된 소스 파일에서만 사용<br>
    정적 전역 변수는 전역 변수를 다른 소스 파일에서 접근하지 못하도록 제한<br><br>

    <table>
        <div>
            <tr>
                <th>구분</th>
                <th>일반 지역 변수</th>
                <th>정적 지역 변수</th>
                <th>전역 변수</th>
                <th>정적 전역 변수</th>
            </tr>
            <tr>
                <td>선언 위치</td>
                <td>함수 안</td>
                <td>함수 안</td>
                <td>함수 밖</td>
                <td>함수 밖</td>
            </tr>
            <tr>
                <td>생성 시점</td>
                <td>변수 선언 시</td>
                <td>프로그램 시작 시</td>
                <td>프로그램 시작 시</td>
                <td>프로그램 시작 시</td>
            </tr>
            <tr>
                <td>해제 시점</td>
                <td>함수 리턴 시</td>
                <td>프로그램 종료 시</td>
                <td>프로그램 종료 시</td>
                <td>프로그램 종료 시</td>
            </tr>
            <tr>
                <td>사용 범위</td>
                <td>함수 안</td>
                <td>함수 안</td>
                <td>프로그램 전체</td>
                <td>선언된 소스 파일</td>
            </tr>
            <tr>
                <td>초기화 하지 않았을 때</td>
                <td>쓰레기 값</td>
                <td>0으로 초기화</td>
                <td>0으로 초기화</td>
                <td>0으로 초기화</td>
            </tr>

        </div>
    </table><br>